<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Paracel - API Reference</title>

    <link href="stylesheets/screen.css" rel="stylesheet" type="text/css" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" type="text/css" media="print" />
    <script src="javascripts/jquery.min.js"></script>
      <script src="javascripts/all_nosearch.js" type="text/javascript"></script>

      <script>
        $(function() {
          setupLanguages(["cpp","python","shell","json"]);
        });
      </script>
  </head>

  <body class="index">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <img src="images/logo.png" />
        <div class="lang-selector">
              <a href="#" data-language-name="cpp">cpp</a>
              <a href="#" data-language-name="python">python</a>
              <a href="#" data-language-name="shell">shell</a>
              <a href="#" data-language-name="json">json</a>
        </div>
      <div id="toc">
      </div>
        <ul class="toc-footer">
            <li><a href='http://paracel.io'>Project Homepage</a></li>
            <li>© 2014-2015, Powered by <a href='http://www.douban.com'>豆瓣</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id="overview">Overview</h1>
<pre><code class="highlight cpp"><span class="n">std</span><span class="o">::</span><span class="n">cout</span>
  <span class="o">&lt;&lt;</span> <span class="s">"(0.5,1)-&gt;(0,0.5)-&gt;(1,0.5)-&gt;(0.5,1)-&gt;(0.5,0.25)-&gt;(0.25,0.25)"</span><span class="p">;</span>
</code></pre>
<pre><code class="highlight python"><span class="k">print</span> <span class="s">'(0.5,1)-&gt;(0,0.5)-&gt;(1,0.5)-&gt;(0.5,1)-&gt;(0.5,0.25)-&gt;(0.25,0.25)'</span>
</code></pre>
<pre><code class="highlight shell"><span class="nb">echo</span> <span class="s2">"(0.5,1)-&gt;(0,0.5)-&gt;(1,0.5)-&gt;(0.5,1)-&gt;(0.5,0.25)-&gt;(0.25,0.25)"</span>
</code></pre>
<pre><code class="highlight json"><span class="p">{</span><span class="w">
  </span><span class="s2">"logo"</span><span class="p">:</span><span class="w"> </span><span class="s2">"(0.5,1)-&gt;(0,0.5)-&gt;(1,0.5)-&gt;(0.5,1)-&gt;(0.5,0.25)-&gt;(0.25,0.25)"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>

<p>Welcome to the Paracel API Reference page!</p>

<p>You can use the interfaces listed here to build your own distributed algorithms or applications following Paracel&rsquo;s paradigm. Till now, Paracel only provides C++ interface for the consideration of computational efficiency. You can view code examples in the right area.</p>

<h1 id="data-representation">Data Representation</h1>

<p>Paracel use <code class="prettyprint">graph</code> and <code class="prettyprint">matrix</code> to represent the training data.</p>

<p>We define four types of <code class="prettyprint">graph</code>:</p>

<ul>
<li><a href="#bigraph">bigraph</a></li>
<li><a href="#bigraph_continuous">bigraph_continuous</a></li>
<li><a href="#digraph">digraph</a></li>
<li><a href="#undirected_graph">undirected_graph</a></li>
</ul>

<p>We import <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen3</a> library for matrix/vector operations. Eigen3 support two types of matrix:</p>

<ul>
<li><a href="#sparsematrix">SparseMatrix</a></li>
<li><a href="#densematrix">MatrixXd</a></li>
</ul>

<aside class="notice">
<p>
1. You can use neither of them and define your own data structure to store the data.<p>
2. All type of graph can be communicated between worker and server while matrix can not.
</aside>

<h2 id="bigraph">Bigraph</h2>
<pre><code class="highlight cpp"><span class="cp">#include "graph.hpp" // paracel::bigraph
#include "paracel_types.hpp"
</span>
<span class="cm">/*
 * G:
 *  a, A, 3
 *  a, B, 4
 *  a, D, 2
 *  b, C, 5
 *  b, D, 4
 *  b, E, 5
 *  c, D, 3
 *  c, E, 1
 *  c, F, 2
 *  d, C, 3
 */</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">paracel</span><span class="o">::</span><span class="n">bigraph</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">G</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">get_data</span><span class="p">();</span>

  <span class="k">auto</span> <span class="n">print_lambda</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">u</span><span class="p">,</span>
                          <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">v</span><span class="p">,</span>
                          <span class="kt">double</span> <span class="n">wgt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u</span> <span class="o">&lt;&lt;</span> <span class="s">"|"</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="s">"|"</span> <span class="o">&lt;&lt;</span> <span class="n">wgt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="n">G</span><span class="p">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">print_lambda</span><span class="p">);</span>

  <span class="n">G</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s">"c"</span><span class="p">,</span> <span class="s">"G"</span><span class="p">,</span> <span class="mf">3.6</span><span class="p">);</span>
  <span class="n">G</span><span class="p">.</span><span class="n">traverse</span><span class="p">(</span><span class="s">"c"</span><span class="p">,</span> <span class="n">print_lambda</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">ubag</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">left_vertex_bag</span><span class="p">();</span> <span class="c1">// a, b, c, d
</span>  <span class="k">auto</span> <span class="n">uset</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">left_vertex_set</span><span class="p">();</span> <span class="c1">// a, b, c, d
</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">dump_tpls</span><span class="p">;</span>
  <span class="n">G</span><span class="p">.</span><span class="n">dump2triples</span><span class="p">(</span><span class="n">dump_tpls</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>
                   <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">dump_dict</span><span class="p">;</span>
  <span class="n">G</span><span class="p">.</span><span class="n">dump2dict</span><span class="p">(</span><span class="n">dump_dict</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">v_sz</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">v</span><span class="p">();</span> <span class="c1">// 4
</span>  <span class="k">auto</span> <span class="n">e_sz</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">e</span><span class="p">();</span> <span class="c1">// 11
</span>  <span class="k">auto</span> <span class="n">od</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">outdegree</span><span class="p">(</span><span class="s">"a"</span><span class="p">);</span> <span class="c1">// 3
</span>  <span class="k">auto</span> <span class="n">id</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">indegree</span><span class="p">(</span><span class="s">"E"</span><span class="p">);</span> <span class="c1">// 2
</span>
  <span class="k">auto</span> <span class="n">adj_info</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">adjacent</span><span class="p">(</span><span class="s">"c"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>

<p>In mathematical field of graph theory, a bipartite graph (or bigraph) is a graph whose vertices can be divided into two disjoint sets <code class="prettyprint">U</code> and <code class="prettyprint">V</code> (that is, <code class="prettyprint">U</code> and <code class="prettyprint">V</code> are each independent sets) such that every edge connects a vertex in <code class="prettyprint">U</code> to one in <code class="prettyprint">V</code>.</p>

<h3 id="template-&lt;class-t-=-paracel::default_id_type&gt;class-bigraph-{&nbsp;public:&nbsp;&nbsp;bigraph();">template &lt;class T = paracel::default_id_type&gt;<br>class bigraph {<br><br>&nbsp;public:<br>&nbsp;&nbsp;bigraph();</h3>

<h3 id="&nbsp;&nbsp;bigraph(std::unordered_map&lt;t,-std::unordered_map&lt;t,-double&gt;-&gt;-edge_info);">&nbsp;&nbsp;bigraph(std::unordered_map&lt;T, std::unordered_map&lt;T, double&gt; &gt; edge_info);</h3>

<h3 id="&nbsp;&nbsp;bigraph(std::vector&lt;std::tuple&lt;t,-t&gt;-&gt;-tpls);">&nbsp;&nbsp;bigraph(std::vector&lt;std::tuple&lt;T, T&gt; &gt; tpls);</h3>

<h3 id="&nbsp;&nbsp;bigraph(std::vector&lt;std::tuple&lt;t,-t,-double&gt;-&gt;-tpls);">&nbsp;&nbsp;bigraph(std::vector&lt;std::tuple&lt;T, T, double&gt; &gt; tpls);</h3>

<h3 id="&nbsp;&nbsp;void-add_edge(const-t-&amp;-v,-const-t-&amp;-w);">&nbsp;&nbsp;void add_edge(const T &amp; v, const T &amp; w);</h3>

<h3 id="&nbsp;&nbsp;void-add_edge(const-t-&amp;-v,-const-t-&amp;-w,-double-wgt);">&nbsp;&nbsp;void add_edge(const T &amp; v, const T &amp; w, double wgt);</h3>

<h3 id="&nbsp;&nbsp;//-return-bigraph-data&nbsp;&nbsp;std::unordered_map&lt;t,-std::unordered_map&lt;t,-double&gt;-&gt;-get_data();">&nbsp;&nbsp;// return bigraph data<br>&nbsp;&nbsp;std::unordered_map&lt;T, std::unordered_map&lt;T, double&gt; &gt; get_data();</h3>

<h3 id="&nbsp;&nbsp;//-traverse-bigraph-edge-using-functor-func&nbsp;&nbsp;template-&lt;class-f&gt;&nbsp;&nbsp;void-traverse(f-&amp;-func);">&nbsp;&nbsp;// traverse bigraph edge using functor <code class="prettyprint">func</code><br>&nbsp;&nbsp;template &lt;class F&gt;<br>&nbsp;&nbsp;void traverse(F &amp; func);</h3>

<h3 id="&nbsp;&nbsp;//-traverse-vertex-v&#39;s-related-edges-using-functor-func&nbsp;&nbsp;template-&lt;class-f&gt;-&nbsp;&nbsp;void-traverse(const-t-&amp;-v,-f-&amp;-func);">&nbsp;&nbsp;// traverse vertex <code class="prettyprint">v</code>&rsquo;s related edges using functor <code class="prettyprint">func</code><br>&nbsp;&nbsp;template &lt;class F&gt; <br>&nbsp;&nbsp;void traverse(const T &amp; v, F &amp; func);</h3>

<h3 id="&nbsp;&nbsp;//-return-u-bag&nbsp;&nbsp;std::vector&lt;t&gt;-left_vertex_bag();">&nbsp;&nbsp;// return <code class="prettyprint">U</code> bag<br>&nbsp;&nbsp;std::vector&lt;T&gt; left_vertex_bag();</h3>

<h3 id="&nbsp;&nbsp;//-return-u-set&nbsp;&nbsp;std::unordered_set&lt;t&gt;-left_vertex_set();">&nbsp;&nbsp;// return <code class="prettyprint">U</code> set<br>&nbsp;&nbsp;std::unordered_set&lt;T&gt; left_vertex_set();</h3>

<h3 id="&nbsp;&nbsp;//-out:-tpls&nbsp;&nbsp;void-dump2triples(std::vector&lt;std::tuple&lt;t,-t,-double&gt;-&gt;-&amp;-tpls);">&nbsp;&nbsp;// out: <code class="prettyprint">tpls</code><br>&nbsp;&nbsp;void dump2triples(std::vector&lt;std::tuple&lt;T, T, double&gt; &gt; &amp; tpls);</h3>

<h3 id="&nbsp;&nbsp;//-out:-dict&nbsp;&nbsp;void-dump2dict(std::unordered_map-&gt;-&amp;-dict);">&nbsp;&nbsp;// out: <code class="prettyprint">dict</code><br>&nbsp;&nbsp;void dump2dict(std::unordered_map<T, std::unordered_map<T, double> &gt; &amp; dict);</h3>

<h3 id="&nbsp;&nbsp;//-return-number-of-vertexes-in-u&nbsp;&nbsp;inline-size_t-v();">&nbsp;&nbsp;// return number of vertexes in <code class="prettyprint">U</code><br>&nbsp;&nbsp;inline size_t v();</h3>

<h3 id="&nbsp;&nbsp;//-return-number-of-edges-in-bigraph&nbsp;&nbsp;inline-size_t-e();">&nbsp;&nbsp;// return number of edges in bigraph<br>&nbsp;&nbsp;inline size_t e();</h3>

<h3 id="&nbsp;&nbsp;//-return-adjacent-info-of-vertex-v&nbsp;&nbsp;std::unordered_map&lt;t,-double&gt;-adjacent(const-t-&amp;-v);">&nbsp;&nbsp;// return adjacent info of vertex <code class="prettyprint">v</code><br>&nbsp;&nbsp;std::unordered_map&lt;T, double&gt; adjacent(const T &amp; v);</h3>

<h3 id="&nbsp;&nbsp;//-return-outdegree-of-vertex-u-in-u&nbsp;&nbsp;inline-size_t-outdegree(const-t-&amp;-u);">&nbsp;&nbsp;// return outdegree of vertex <code class="prettyprint">u</code> in <code class="prettyprint">U</code><br>&nbsp;&nbsp;inline size_t outdegree(const T &amp; u);</h3>

<h3 id="&nbsp;&nbsp;//-return-indegree-of-vertex-v-in-v&nbsp;&nbsp;inline-size_t-indegree(const-t-&amp;-v);">&nbsp;&nbsp;// return indegree of vertex <code class="prettyprint">v</code> in <code class="prettyprint">V</code><br>&nbsp;&nbsp;inline size_t indegree(const T &amp; v);</h3>

<h3 id="};">};</h3>

<h2 id="bigraph_continuous">Bigraph_continuous</h2>
<pre><code class="highlight cpp"><span class="cp">#include "graph.hpp" // paracel::bigraph_continuous
#include "paracel_types.hpp"
</span>
<span class="cm">/*
 * G:
 *  0, 1, 3
 *  0, 2, 4
 *  0, 4, 2
 *  1, 3, 5
 *  1, 4, 4
 *  1, 5, 5
 *  2, 4, 3
 *  2, 5, 1
 *  2, 6, 2
 *  3, 3, 3
 */</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>

  <span class="n">paracel</span><span class="o">::</span><span class="n">bigraph_continuous</span> <span class="n">G</span><span class="p">;</span>
  <span class="n">G</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">3.</span><span class="p">);</span>
  <span class="n">G</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">4.</span><span class="p">);</span>
  <span class="n">G</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">2.</span><span class="p">);</span>
  <span class="n">G</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">5.</span><span class="p">);</span>
  <span class="n">G</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">4.</span><span class="p">);</span>
  <span class="n">G</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">5.</span><span class="p">);</span>
  <span class="n">G</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">3.</span><span class="p">);</span>
  <span class="n">G</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">1.</span><span class="p">);</span>
  <span class="n">G</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mf">2.</span><span class="p">);</span>
  <span class="n">G</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">3.</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">print_lambda</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="n">paracel</span><span class="o">::</span><span class="n">default_id_type</span> <span class="n">u</span><span class="p">,</span>
                          <span class="n">paracel</span><span class="o">::</span><span class="n">default_id_type</span> <span class="n">v</span><span class="p">,</span>
                          <span class="kt">double</span> <span class="n">wgt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u</span> <span class="o">&lt;&lt;</span> <span class="s">"|"</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="s">"|"</span> <span class="o">&lt;&lt;</span> <span class="n">wgt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="n">G</span><span class="p">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">print_lambda</span><span class="p">);</span>
  <span class="n">G</span><span class="p">.</span><span class="n">traverse</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">print_lambda</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">v_sz</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">v</span><span class="p">();</span> <span class="c1">// 4
</span>  <span class="k">auto</span> <span class="n">e_sz</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">e</span><span class="p">();</span> <span class="c1">// 10
</span>  <span class="k">auto</span> <span class="n">od</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">outdegree</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 3
</span>  <span class="k">auto</span> <span class="n">id</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">indegree</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 2
</span>
  <span class="k">auto</span> <span class="n">adj_info</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">adjacent</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>

<p><code class="prettyprint">paracel::bigraph_continous</code> can also be used to represent a bipartite graph. Vertexes of a <code class="prettyprint">paracel::bigraph_continuous</code> must be indexed from 0 to N-1(N is the number of total number of vertexes in <code class="prettyprint">U</code>). It will cost less memory comparing to <code class="prettyprint">paracel::bigraph&lt;paracel::default_id_type&gt;</code> and will be more efficent since it is continous, the interface below is similar.</p>

<h3 id="class-bigraph_continuous-{&nbsp;public:&nbsp;&nbsp;bigraph_continuous();">class bigraph_continuous {<br><br>&nbsp;public:<br>&nbsp;&nbsp;bigraph_continuous();</h3>

<h3 id="&nbsp;&nbsp;bigraph_continuous(paracel::default_id_type-n);">&nbsp;&nbsp;bigraph_continuous(paracel::default_id_type n);</h3>

<h3 id="&nbsp;&nbsp;//-sequential-interface,-first-row-of-file-filename-is-size-of-u&nbsp;&nbsp;bigraph_continuous(const-std::string-&amp;-filename);">&nbsp;&nbsp;// sequential interface, first row of file <code class="prettyprint">filename</code> is size of <code class="prettyprint">U</code><br>&nbsp;&nbsp;bigraph_continuous(const std::string &amp; filename);</h3>

<h3 id="&nbsp;&nbsp;void-add_edge(paracel::default_id_type-src,&ensp;&ensp;&ensp;&ensp;paracel::default_id_type-dst);">&nbsp;&nbsp;void add_edge(paracel::default_id_type src,<br>&ensp;&ensp;&ensp;&ensp;paracel::default_id_type dst);</h3>

<h3 id="&nbsp;&nbsp;void-add_edge(paracel::default_id_type-src,&ensp;&ensp;&ensp;&ensp;paracel::default_id_type-dst,&ensp;&ensp;&ensp;&ensp;double-rating);">&nbsp;&nbsp;void add_edge(paracel::default_id_type src,<br>&ensp;&ensp;&ensp;&ensp;paracel::default_id_type dst,<br>&ensp;&ensp;&ensp;&ensp;double rating);</h3>

<h3 id="&nbsp;&nbsp;//-return-number-of-vertexes-in-u&nbsp;&nbsp;paracel::default_id_type-v();">&nbsp;&nbsp;// return number of vertexes in <code class="prettyprint">U</code><br>&nbsp;&nbsp;paracel::default_id_type v();</h3>

<h3 id="&nbsp;&nbsp;//-return-number-of-edges-in-bigraph_continuous&nbsp;&nbsp;paracel::default_id_type-e();">&nbsp;&nbsp;// return number of edges in bigraph_continuous<br>&nbsp;&nbsp;paracel::default_id_type e();</h3>

<h3 id="&nbsp;&nbsp;//-return-adjacent-info-of-vertex-v&nbsp;&nbsp;paracel::bag_type&lt;std::pair&lt;paracel::default_id_type,-double&gt;-&gt;-&nbsp;&nbsp;adjacent(paracel::default_id_type-v);">&nbsp;&nbsp;// return adjacent info of vertex <code class="prettyprint">v</code><br>&nbsp;&nbsp;paracel::bag_type&lt;std::pair&lt;paracel::default_id_type, double&gt; &gt; &nbsp;&nbsp;adjacent(paracel::default_id_type v);</h3>

<h3 id="&nbsp;&nbsp;//-return-outdegree-of-vertex-u-in-u&nbsp;&nbsp;inline-size_t-outdegree(paracel::default_id_type-u);">&nbsp;&nbsp;// return outdegree of vertex <code class="prettyprint">u</code> in <code class="prettyprint">U</code><br>&nbsp;&nbsp;inline size_t outdegree(paracel::default_id_type u);</h3>

<h3 id="&nbsp;&nbsp;//-return-indegree-of-vertex-v-in-v&nbsp;&nbsp;inline-size_t-indegree(paracel::default_id_type-v);">&nbsp;&nbsp;// return indegree of vertex <code class="prettyprint">v</code> in <code class="prettyprint">V</code><br>&nbsp;&nbsp;inline size_t indegree(paracel::default_id_type v);</h3>

<h3 id="&nbsp;&nbsp;//-traverse-bigraph-edge-using-functor-func&nbsp;&nbsp;template-&lt;class-f&gt;&nbsp;&nbsp;void-traverse(f-&amp;-func);">&nbsp;&nbsp;// traverse bigraph edge using functor <code class="prettyprint">func</code><br>&nbsp;&nbsp;template &lt;class F&gt;<br>&nbsp;&nbsp;void traverse(F &amp; func);</h3>

<h3 id="&nbsp;&nbsp;//-traverse-vertex-v’s-related-edges-using-functor-func&nbsp;&nbsp;template-&lt;class-f&gt;&nbsp;&nbsp;void-traverse(paracel::default_id_type-v,-f-&amp;-func);">&nbsp;&nbsp;// traverse vertex <code class="prettyprint">v</code>’s related edges using functor <code class="prettyprint">func</code><br>&nbsp;&nbsp;template &lt;class F&gt;<br>&nbsp;&nbsp;void traverse(paracel::default_id_type v, F &amp; func);</h3>

<h3 id="};">};</h3>

<h2 id="digraph">Digraph</h2>
<pre><code class="highlight cpp"><span class="cp">#include "graph.hpp" // paracel::digraph
#include "paracel_types.hpp"
</span>
<span class="cm">/*
 * G:
 *   0, 0, 3.0
 *   0, 2, 5.0
 *   1, 0, 4.0
 *   1, 1, 3.0
 *   1, 2, 1.0
 *   2, 0, 2.0
 *   2, 3, 1.0
 *   3, 1, 3.0
 *   3, 3, 1.0
 */</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">paracel</span><span class="o">::</span><span class="n">digraph</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">G</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">G</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">5.</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">get_data</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">vbag</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">vertex_bag</span><span class="p">();</span> <span class="c1">// std::vector&lt;size_t&gt;({0, 1, 2, 3, 4})
</span>  <span class="k">auto</span> <span class="n">vset</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">vertex_set</span><span class="p">();</span> <span class="c1">// unordered_set&lt;size_t&gt;({0, 1, 2, 3, 4})
</span>  <span class="k">auto</span> <span class="n">adj</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">adjacent</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// {0 : 3.0; 2 : 5.0}
</span>
  <span class="k">auto</span> <span class="n">print_lambda</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">a</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">b</span><span class="p">,</span> <span class="kt">double</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" | "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="s">" | "</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="n">grp</span><span class="p">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">print_lambda</span><span class="p">);</span>
  <span class="n">grp</span><span class="p">.</span><span class="n">traverse</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">print_lambda</span><span class="p">);</span> <span class="c1">// 1|3|4.0\n1|1|3.0\n1|2|1.0, order does not matter
</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">dump_tpls</span><span class="p">;</span>
  <span class="n">G</span><span class="p">.</span><span class="n">dump2triples</span><span class="p">(</span><span class="n">dump_tpls</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span>
                   <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">dump_dict</span><span class="p">;</span>
  <span class="n">G</span><span class="p">.</span><span class="n">dump2dict</span><span class="p">(</span><span class="n">dump_dict</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">v_sz</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">v</span><span class="p">();</span> <span class="c1">// 5
</span>  <span class="k">auto</span> <span class="n">e_sz</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">e</span><span class="p">();</span> <span class="c1">// 10
</span>  <span class="k">auto</span> <span class="n">od</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">outdegree</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 2
</span>  <span class="k">auto</span> <span class="n">id</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">indegree</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 2
</span>  <span class="k">auto</span> <span class="n">ad</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">avg_degree</span><span class="p">();</span> <span class="c1">// 2
</span>  <span class="k">auto</span> <span class="n">sl</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">selfloops</span><span class="p">();</span> <span class="c1">// 3
</span>
  <span class="n">grp</span><span class="p">.</span><span class="n">reverse</span><span class="p">();</span>
  <span class="n">v_sz</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">v</span><span class="p">();</span> <span class="c1">// 5
</span>  <span class="n">e_sz</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">e</span><span class="p">();</span> <span class="c1">// 10
</span>  <span class="n">od</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">outdegree</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 3
</span>  <span class="n">id</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">indegree</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 2
</span>  <span class="n">ad</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">avg_degree</span><span class="p">();</span> <span class="c1">// 2
</span>  <span class="n">sl</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">selfloops</span><span class="p">();</span> <span class="c1">// 3
</span>
<span class="p">}</span>
</code></pre>

<p><code class="prettyprint">paracel::digraph</code> can be used to represent a weighted directed graph. You can use it to develop graph algorithms such as <a href="http://en.wikipedia.org/wiki/PageRank">pagerank</a>. Iterfaces of <code class="prettyprint">digraph</code> are quite similar with <a href="#undirected_graph">paracel::undirected_graph</a>.</p>

<h3 id="template-&lt;class-t-=-paracel::default_id_type&gt;class-digraph-{&nbsp;public:&nbsp;&nbsp;digraph();">template &lt;class T = paracel::default_id_type&gt;<br>class digraph {<br><br>&nbsp;public:<br>&nbsp;&nbsp;digraph();</h3>

<h3 id="&nbsp;&nbsp;digraph(std::unordered_map&lt;t,-std::unordered_map&lt;t,-double&gt;-&gt;-edge_info);">&nbsp;&nbsp;digraph(std::unordered_map&lt;T, std::unordered_map&lt;T, double&gt; &gt; edge_info);</h3>

<h3 id="&nbsp;&nbsp;digraph(std::vector&lt;std::tuple&lt;t,-t&gt;-&gt;-tpls);">&nbsp;&nbsp;digraph(std::vector&lt;std::tuple&lt;T, T&gt; &gt; tpls);</h3>

<h3 id="&nbsp;&nbsp;digraph(std::vector&lt;std::tuple&lt;t,-t,-double&gt;-&gt;-tpls);">&nbsp;&nbsp;digraph(std::vector&lt;std::tuple&lt;T, T, double&gt; &gt; tpls);</h3>

<h3 id="&nbsp;&nbsp;void-add_edge(const-t-&amp;-v,-const-t-&amp;-w);">&nbsp;&nbsp;void add_edge(const T &amp; v, const T &amp; w);</h3>

<h3 id="&nbsp;&nbsp;void-add_edge(const-t-&amp;-v,-const-t-&amp;-w,-double-wgt);">&nbsp;&nbsp;void add_edge(const T &amp; v, const T &amp; w, double wgt);</h3>

<h3 id="&nbsp;&nbsp;//-return-digraph-data&nbsp;&nbsp;std::unordered_map-&gt;-get_data();">&nbsp;&nbsp;// return digraph data<br>&nbsp;&nbsp;std::unordered_map<T, std::unordered_map<T, double> &gt; get_data();</h3>

<h3 id="&nbsp;&nbsp;//-traverse-bigraph-edge-using-functor-func&nbsp;&nbsp;template-&lt;class-f&gt;&nbsp;&nbsp;void-traverse(f-&amp;-func);">&nbsp;&nbsp;// traverse bigraph edge using functor <code class="prettyprint">func</code><br>&nbsp;&nbsp;template &lt;class F&gt;<br>&nbsp;&nbsp;void traverse(F &amp; func);</h3>

<h3 id="&nbsp;&nbsp;//-traverse-vertex-v’s-related-edges-using-functor-func&nbsp;&nbsp;template-&lt;class-f&gt;&nbsp;&nbsp;void-traverse(const-t-&amp;-v,-f-&amp;-func);">&nbsp;&nbsp;// traverse vertex <code class="prettyprint">v</code>’s related edges using functor <code class="prettyprint">func</code><br>&nbsp;&nbsp;template &lt;class F&gt;<br>&nbsp;&nbsp;void traverse(const T &amp; v, F &amp; func);</h3>

<h3 id="&nbsp;&nbsp;template-&lt;class-f&gt;&nbsp;&nbsp;void-traverse_by_vertex(f-&amp;-func);">&nbsp;&nbsp;template &lt;class F&gt;<br>&nbsp;&nbsp;void traverse_by_vertex(F &amp; func);</h3>

<h3 id="&nbsp;&nbsp;//-return-vertexes-of-digraph-with-std::vector&nbsp;&nbsp;std::vector&lt;t&gt;-vertex_bag();">&nbsp;&nbsp;// return vertexes of digraph with std::vector<br>&nbsp;&nbsp;std::vector&lt;T&gt; vertex_bag();</h3>

<h3 id="&nbsp;&nbsp;//-return-vertexes-of-digraph-with-std::unordered_set&nbsp;&nbsp;std::unordered_set&lt;t&gt;-vertex_set();">&nbsp;&nbsp;// return vertexes of digraph with std::unordered_set<br>&nbsp;&nbsp;std::unordered_set&lt;T&gt; vertex_set();</h3>

<h3 id="&nbsp;&nbsp;//-out:-tpls&nbsp;&nbsp;void-dump2triples(std::vector&lt;std::tuple&lt;t,-t,-double&gt;-&gt;-&amp;-tpls);">&nbsp;&nbsp;// out: <code class="prettyprint">tpls</code><br>&nbsp;&nbsp;void dump2triples(std::vector&lt;std::tuple&lt;T, T, double&gt; &gt; &amp; tpls);</h3>

<h3 id="&nbsp;&nbsp;//-out:-dict&nbsp;&nbsp;void-dump2dict(std::unordered_map&lt;t,-std::unordered_map&lt;t,-double&gt;-&gt;-&amp;-dict);">&nbsp;&nbsp;// out: <code class="prettyprint">dict</code><br>&nbsp;&nbsp;void dump2dict(std::unordered_map&lt;T, std::unordered_map&lt;T, double&gt; &gt; &amp; dict);</h3>

<h3 id="&nbsp;&nbsp;//-reverse-digraph-with-edge-direction&nbsp;&nbsp;digraph-reverse();">&nbsp;&nbsp;// reverse digraph with edge direction<br>&nbsp;&nbsp;digraph reverse();</h3>

<h3 id="&nbsp;&nbsp;//-return-total-number-of-vertexes&nbsp;&nbsp;inline-size_t-v();">&nbsp;&nbsp;// return total number of vertexes<br>&nbsp;&nbsp;inline size_t v();</h3>

<h3 id="&nbsp;&nbsp;//-return-total-number-of-edges&nbsp;&nbsp;inline-size_t-e();">&nbsp;&nbsp;// return total number of edges<br>&nbsp;&nbsp;inline size_t e();</h3>

<h3 id="&nbsp;&nbsp;//-return-adjacent-info-of-vertex-v&nbsp;&nbsp;std::unordered_map&lt;t,-double&gt;&nbsp;&nbsp;adjacent(const-t-&amp;-v);">&nbsp;&nbsp;// return adjacent info of vertex <code class="prettyprint">v</code><br>&nbsp;&nbsp;std::unordered_map&lt;T, double&gt;<br>&nbsp;&nbsp;adjacent(const T &amp; v);</h3>

<h3 id="&nbsp;&nbsp;unordered_map&lt;t,-double&gt;&nbsp;&nbsp;reverse_adjacent(const-t-&amp;-v);">&nbsp;&nbsp;unordered_map&lt;T, double&gt;<br>&nbsp;&nbsp;reverse_adjacent(const T &amp; v);</h3>

<h3 id="&nbsp;&nbsp;//-return-outdegree-of-vertex-v&nbsp;&nbsp;inline-size_t-outdegree(const-t-&amp;-v);">&nbsp;&nbsp;// return outdegree of vertex <code class="prettyprint">v</code><br>&nbsp;&nbsp;inline size_t outdegree(const T &amp; v);</h3>

<h3 id="&nbsp;&nbsp;//-return-indegree-of-vertex-v&nbsp;&nbsp;inline-size_t-indegree(const-t-&amp;-v);">&nbsp;&nbsp;// return indegree of vertex <code class="prettyprint">v</code><br>&nbsp;&nbsp;inline size_t indegree(const T &amp; v);</h3>

<h3 id="&nbsp;&nbsp;//-return-average-degree-of-digraph&nbsp;&nbsp;inline-double-avg_degree();">&nbsp;&nbsp;// return average degree of digraph<br>&nbsp;&nbsp;inline double avg_degree();</h3>

<h3 id="&nbsp;&nbsp;//-return-total-number-of-self-loops-of-digraph&nbsp;&nbsp;inline-int-selfloops();">&nbsp;&nbsp;// return total number of self-loops of digraph<br>&nbsp;&nbsp;inline int selfloops();</h3>

<h2 id="undirected_graph">Undirected_graph</h2>
<pre><code class="highlight cpp"><span class="cp">#include "graph.hpp" // paracel::undirected_graph
#include "paracel_types.hpp"
</span>
<span class="cm">/*
 * G:
 *   0, 1
 *   0, 2
 *   0, 5
 *   0, 6
 *   3, 4
 *   3, 5
 *   4, 5
 *   4, 6
 *   9, 10
 *   9, 11
 *   9, 12
 *   11, 12
 */</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">paracel</span><span class="o">::</span><span class="n">undirected_graph</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">G</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">v_sz</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">v</span><span class="p">();</span> <span class="c1">// 11
</span>  <span class="k">auto</span> <span class="n">e_sz</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">e</span><span class="p">();</span> <span class="c1">// 12
</span>  <span class="k">auto</span> <span class="n">adj</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">adjacent</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// {0: 1.0, 4:1.0}
</span>  <span class="k">auto</span> <span class="n">ad</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">avg_degree</span><span class="p">();</span> <span class="c1">// 24. / 11.
</span>  <span class="k">auto</span> <span class="n">md</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">max_degree</span><span class="p">();</span> <span class="c1">// 4
</span>  <span class="k">auto</span> <span class="n">sl</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">selfloops</span><span class="p">();</span> <span class="c1">// 0
</span>  <span class="k">auto</span> <span class="n">print_lambda</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">a</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">b</span><span class="p">,</span> <span class="kt">double</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" | "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="s">" | "</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="n">G</span><span class="p">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">print_lambda</span><span class="p">);</span>
  <span class="n">G</span><span class="p">.</span><span class="n">traverse</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">print_lambda</span><span class="p">);</span> <span class="c1">// 0|1|1.0\n0|2|1.0\n0|5|1.0\n0|6|1.0, order does not matter
</span><span class="p">}</span>
</code></pre>

<p><code class="prettyprint">paracel::undirected_graph</code> can be used to represent a weighted undirected graph. You can use it to develop graph algorithms. Interfaces of <code class="prettyprint">undirected_graph</code> are quite similar with <a href="#digraph">paracel::digraph</a>.</p>

<h3 id="template-&lt;class-t-=-size_t&gt;class-undirected_graph-{&nbsp;public:&nbsp;&nbsp;undirected_graph();">template &lt;class T = size_t&gt;<br>class undirected_graph {<br><br>&nbsp;public:<br>&nbsp;&nbsp;undirected_graph();</h3>

<h3 id="&nbsp;&nbsp;undirected_graph(std::unordered_map&lt;t,-std::unordered_map&lt;t,-double&gt;-&gt;-edge_info);">&nbsp;&nbsp;undirected_graph(std::unordered_map&lt;T, std::unordered_map&lt;T, double&gt; &gt; edge_info);</h3>

<h3 id="&nbsp;&nbsp;undirected_graph(std::vector&lt;std::tuple&lt;t,-t&gt;-&gt;-tpls);">&nbsp;&nbsp;undirected_graph(std::vector&lt;std::tuple&lt;T, T&gt; &gt; tpls);</h3>

<h3 id="&nbsp;&nbsp;undirected_graph(std::vector&lt;std::tuple&lt;t,-t,-double&gt;-&gt;-tpls);">&nbsp;&nbsp;undirected_graph(std::vector&lt;std::tuple&lt;T, T, double&gt; &gt; tpls);</h3>

<h3 id="&nbsp;&nbsp;void-add_edge(const-t-&amp;-v,-const-t-&amp;-w);">&nbsp;&nbsp;void add_edge(const T &amp; v, const T &amp; w);</h3>

<h3 id="&nbsp;&nbsp;void-add_edge(const-t-&amp;-v,-const-t-&amp;-w,-double-wgt);">&nbsp;&nbsp;void add_edge(const T &amp; v, const T &amp; w, double wgt);</h3>

<h3 id="&nbsp;&nbsp;//-return-undirected_graph-data&nbsp;&nbsp;unordered_map-&gt;-get_data();">&nbsp;&nbsp;// return undirected_graph data<br>&nbsp;&nbsp;unordered_map<T, std::unordered_map<T, double> &gt; get_data();</h3>

<h3 id="&nbsp;&nbsp;//-traverse-undirected_graph-edge-using-functor-func&nbsp;&nbsp;template-&lt;class-f&gt;&nbsp;&nbsp;void-traverse(f-&amp;-func);">&nbsp;&nbsp;// traverse undirected_graph edge using functor <code class="prettyprint">func</code><br>&nbsp;&nbsp;template &lt;class F&gt;<br>&nbsp;&nbsp;void traverse(F &amp; func);</h3>

<h3 id="&nbsp;&nbsp;//-traverse-vertex-v’s-related-edges-using-functor-func&nbsp;&nbsp;template-&lt;class-f&gt;&nbsp;&nbsp;oid-traverse(const-t-&amp;-v,-f-&amp;-func);">&nbsp;&nbsp;// traverse vertex <code class="prettyprint">v</code>’s related edges using functor <code class="prettyprint">func</code><br>&nbsp;&nbsp;template &lt;class F&gt;<br>&nbsp;&nbsp;oid traverse(const T &amp; v, F &amp; func);</h3>

<h3 id="&nbsp;&nbsp;template-&lt;class-f&gt;&nbsp;&nbsp;void-traverse_by_vertex(f-&amp;-func);">&nbsp;&nbsp;template &lt;class F&gt;<br>&nbsp;&nbsp;void traverse_by_vertex(F &amp; func);</h3>

<h3 id="&nbsp;&nbsp;//-return-vertexes-of-undirected_graph-with-std::vector&nbsp;&nbsp;std::vector-vertex_bag();">&nbsp;&nbsp;// return vertexes of undirected_graph with std::vector<br>&nbsp;&nbsp;std::vector<T> vertex_bag();</h3>

<h3 id="&nbsp;&nbsp;//-return-vertexes-of-undirected_graph-with-std::unordered_set&nbsp;&nbsp;std::unordered_set-vertex_set();">&nbsp;&nbsp;// return vertexes of undirected_graph with std::unordered_set<br>&nbsp;&nbsp;std::unordered_set<T> vertex_set();</h3>

<h3 id="&nbsp;&nbsp;//-return-total-number-of-vertexes&nbsp;&nbsp;inline-size_t-v();">&nbsp;&nbsp;// return total number of vertexes<br>&nbsp;&nbsp;inline size_t v();</h3>

<h3 id="&nbsp;&nbsp;//-return-total-number-of-edges&nbsp;&nbsp;inline-size_t-e();">&nbsp;&nbsp;// return total number of edges<br>&nbsp;&nbsp;inline size_t e();</h3>

<h3 id="&nbsp;&nbsp;//-return-adjacent-info-of-vertex-v&nbsp;&nbsp;std::unordered_map&lt;t,-double&gt;&nbsp;&nbsp;adjacent(const-t-&amp;-v);">&nbsp;&nbsp;// return adjacent info of vertex <code class="prettyprint">v</code><br>&nbsp;&nbsp;std::unordered_map&lt;T, double&gt;<br>&nbsp;&nbsp;adjacent(const T &amp; v);</h3>

<h3 id="&nbsp;&nbsp;//-return-outdegree-of-vertex-v&nbsp;&nbsp;inline-size_t-outdegree(const-t-&amp;-v);">&nbsp;&nbsp;// return outdegree of vertex <code class="prettyprint">v</code><br>&nbsp;&nbsp;inline size_t outdegree(const T &amp; v);</h3>

<h3 id="&nbsp;&nbsp;//-return-indegree-of-vertex-v&nbsp;&nbsp;inline-size_t-indegree(const-t-&amp;-v);">&nbsp;&nbsp;// return indegree of vertex <code class="prettyprint">v</code><br>&nbsp;&nbsp;inline size_t indegree(const T &amp; v);</h3>

<h3 id="&nbsp;&nbsp;//-return-average-degree-of-digraph&nbsp;&nbsp;inline-double-avg_degree();">&nbsp;&nbsp;// return average degree of digraph<br>&nbsp;&nbsp;inline double avg_degree();</h3>

<h3 id="&nbsp;&nbsp;//-return-total-number-of-self-loops-of-digraph&nbsp;&nbsp;inline-int-selfloops();">&nbsp;&nbsp;// return total number of self-loops of digraph<br>&nbsp;&nbsp;inline int selfloops();</h3>

<h2 id="more-graph-operation">More Graph Operation</h2>

<h2 id="sparsematrix">SparseMatrix</h2>
<pre><code class="highlight cpp"><span class="cp">#include &lt;vector&gt;
#include &lt;eigen3/Eigen/Dense&gt;
#include &lt;eigen3/Eigen/Sparse&gt;
#include &lt;eigen3/Eigen/QR&gt;
#include &lt;eigen3/Eigen/Cholesky&gt;
#include "utils.hpp"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">mtx</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mtx</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">mtx</span> <span class="o">&lt;&lt;</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span>
        <span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">,</span>
        <span class="mf">7.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="mf">9.</span><span class="p">,</span>
        <span class="mf">10.</span><span class="p">,</span> <span class="mf">11.</span><span class="p">,</span> <span class="mf">12.</span><span class="p">;</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">clusters_mtx</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">c1</span> <span class="o">=</span> <span class="p">{</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">},</span> <span class="n">c2</span> <span class="o">=</span> <span class="p">{</span><span class="mf">8.5</span><span class="p">,</span> <span class="mf">9.5</span><span class="p">,</span> <span class="mf">10.5</span><span class="p">};</span>
  <span class="n">clusters_mtx</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">paracel</span><span class="o">::</span><span class="n">vec2evec</span><span class="p">(</span><span class="n">c1</span><span class="p">);</span>
  <span class="n">clusters_mtx</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">paracel</span><span class="o">::</span><span class="n">vec2evec</span><span class="p">(</span><span class="n">c2</span><span class="p">);</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">mtx</span><span class="p">.</span><span class="n">rows</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="o">::</span><span class="n">Index</span> <span class="n">indx</span><span class="p">;</span>
    <span class="p">(</span><span class="n">clusters_mtx</span><span class="p">.</span><span class="n">rowwise</span><span class="p">()</span> <span class="o">-</span> <span class="n">mtx</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
      <span class="p">.</span><span class="n">rowwise</span><span class="p">()</span>
      <span class="p">.</span><span class="n">squaredNorm</span><span class="p">()</span>
      <span class="p">.</span><span class="n">minCoeff</span><span class="p">(</span><span class="o">&amp;</span><span class="n">indx</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"| "</span> <span class="o">&lt;&lt;</span> <span class="n">indx</span> <span class="o">&lt;&lt;</span> <span class="s">" |"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">typedef</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Triplet</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">eigen_triple</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">eigen_triple</span><span class="o">&gt;</span> <span class="n">tpls</span><span class="p">;</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">));</span>
  <span class="n">tpls</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">eigen_triple</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">));</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">RowMajor</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">;</span>
  <span class="n">A</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
  <span class="n">A</span><span class="p">.</span><span class="n">setFromTriplets</span><span class="p">(</span><span class="n">tpls</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">tpls</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">H</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 5 * 3
</span>  <span class="n">H</span> <span class="o">&lt;&lt;</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span>
      <span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">,</span>
      <span class="mf">7.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="mf">9.</span><span class="p">,</span>
      <span class="mf">10.</span><span class="p">,</span> <span class="mf">11.</span><span class="p">,</span> <span class="mf">12.</span><span class="p">,</span>
      <span class="mf">13.</span><span class="p">,</span> <span class="mf">14.</span><span class="p">,</span> <span class="mf">15.</span><span class="p">;</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">W</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">W</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">W</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">H</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">W</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>

<p>Paracel import <code class="prettyprint">Eigen::SparseMatrix</code> as sparse matrix representation. Check out more details <a href="http://eigen.tuxfamily.org/index.php?title=SparseMatrix">here</a>. You can directly use it to develop your sparse matrix related application. In the code area, we show a brief usage of <code class="prettyprint">Eigen::SparseMatrix</code>. <code class="prettyprint">Eigen::SparseVector</code> is similar usage.</p>

<h3 id="//-std::vector-to-eigen::vectorxdeigen::vectorxd-vec2evec(const-std::vector-&amp;-v);">// std::vector to Eigen::VectorXd<br>Eigen::VectorXd vec2evec(const std::vector<double> &amp; v);</h3>

<h3 id="//-eigen::vectorxd-to-std::vectorstd::vector-evec2vec(const-eigen::vectorxd-&amp;-ev);">// Eigen::VectorXd to std::vector<br>std::vector<double> evec2vec(const Eigen::VectorXd &amp; ev);</h3>

<h3 id="//-traverse-eigen::sparsevector-v-with-functor-functemplate-&lt;class-f&gt;void-traverse_vector(eigen::sparsevector&lt;double&gt;-&amp;-v,-f-&amp;-func);">// traverse Eigen::SparseVector <code class="prettyprint">v</code> with functor <code class="prettyprint">func</code><br>template &lt;class F&gt;<br>void traverse_vector(Eigen::SparseVector&lt;double&gt; &amp; v, F &amp; func);</h3>

<h3 id="//-traverse-eigen::sparsematrix-m-with-functor-functemplate-&lt;class-f&gt;void-traverse_matrix(eigen::sparsematrix&lt;double,-eigen::rowmajor&gt;-&amp;-m,-f-&amp;-func);">// traverse Eigen::SparseMatrix <code class="prettyprint">m</code> with functor <code class="prettyprint">func</code><br>template &lt;class F&gt;<br>void traverse_matrix(Eigen::SparseMatrix&lt;double, Eigen::RowMajor&gt; &amp; m, F &amp; func);</h3>

<h2 id="densematrix">DenseMatrix</h2>
<pre><code class="highlight cpp"><span class="cp">#include &lt;eigen3/Eigen/Dense&gt;
#include &lt;iostream&gt;
#include "utils.hpp"
</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">.</span><span class="n">precision</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">H_blk</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">stone</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="o">::</span><span class="n">Random</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">H_blk</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">stone</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">H_blk</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">stone</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">H_blk</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">stone</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">H_blk</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="n">stone</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">stone</span><span class="p">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">stone</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">kk</span> <span class="o">=</span> <span class="n">H_blk</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">).</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">H_blk</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">kk2</span> <span class="o">=</span> <span class="n">H_blk</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">).</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">H_blk</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">tt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">tt</span> <span class="o">&lt;&lt;</span>
    <span class="n">kk</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">kk2</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">kk</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">kk2</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">kk</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">kk2</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">2</span><span class="p">],</span>
    <span class="n">kk</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">kk2</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">kk</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">kk2</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">kk</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">kk2</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">2</span><span class="p">],</span>
    <span class="n">kk</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">kk2</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">kk</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">kk2</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">kk</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">kk2</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">2</span><span class="p">];</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tt</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tt</span><span class="p">.</span><span class="n">inverse</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">H_blk</span><span class="p">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">H_blk</span><span class="p">).</span><span class="n">inverse</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">goo</span><span class="p">()</span> <span class="p">{</span>

  <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">m</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span>
      <span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">v</span> <span class="o">=</span> <span class="n">paracel</span><span class="o">::</span><span class="n">mat2vec</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="n">vv</span> <span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vv</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 1\n4\n2\n5\n3\n6
</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">mat</span> <span class="o">=</span> <span class="n">paracel</span><span class="o">::</span><span class="n">vec2mat</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 3 is columns
</span>  <span class="c1">// 1 2 3
</span>  <span class="c1">// 4 5 6
</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mat</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">foo</span><span class="p">();</span>
  <span class="n">goo</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>

<p>Paracel import <code class="prettyprint">Eigen::MatrixXd</code> as dense matrix represestation. Check out more details <a href="http://eigen.tuxfamily.org/dox/group__DenseMatrixManipulation__chapter.html">here</a>. You can directly use it to develop your matrix related application. In the right code area, we show a brief usage of <code class="prettyprint">Eigen::MatrixXd</code>.</p>

<h3 id="//-eigen::matrixxd-is-column-major-and-return-col-seqstd::vector-mat2vec(const-eigen::matrixxd-&amp;-m);">// Eigen::MatrixXd is column-major and return col seq<br>std::vector<double> mat2vec(const Eigen::MatrixXd &amp; m);</h3>

<h3 id="//-return-row-seqeigen::matrixxd-vec2mat(const-std::vector-&amp;-v,-size_t-rows);">// return row seq<br>Eigen::MatrixXd vec2mat(const std::vector<double> &amp; v, size_t rows);</h3>

<aside class="notice">
Since Paracel do not support Eigen::MatrixXd for communication between worker and parameter server, we provide mat2vec and vec2mat interface above. You can also do it yourself converting Eigen::SparseMatrix and Eigen::MatrixXd to stl containers.
</aside>

<h1 id="paralg">Paralg</h1>

<p><code class="prettyprint">Paralg</code> is the basic class providing a marjority of functionalities of Paracel. Writing a Paracel program involves subclassing the <code class="prettyprint">paralg</code> baseclass and you have to override the virtual <code class="prettyprint">solve</code> method. Some of them are <a href="http://en.wikipedia.org/wiki/SPMD">SPMD</a> iterfaces, we will call them parallel interfaces in the following.</p>

<h2 id="initialize">Initialize</h2>
<pre><code class="highlight cpp"><span class="cp">#include &lt;google/gflags.h&gt;
#include "ps.hpp"
#include "utils.hpp"
</span>
<span class="k">class</span> <span class="nc">foo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">paracel</span><span class="o">::</span><span class="n">paralg</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">foo</span><span class="p">(</span><span class="n">paracel</span><span class="o">::</span><span class="n">Comm</span> <span class="n">comm</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">hosts_dct_str</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_output</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="o">:</span> <span class="n">paracel</span><span class="o">::</span><span class="n">paralg</span><span class="p">(</span><span class="n">hosts_dct_str</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">_output</span><span class="p">),</span> <span class="n">topk</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">solve</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">topk</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">DEFINE_string</span><span class="p">(</span><span class="n">server_info</span><span class="p">,</span>
              <span class="s">"host1:7777PARACELhost2:8888"</span><span class="p">,</span>
              <span class="s">"hosts name string of paracel-servers.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">paracel</span><span class="o">::</span><span class="n">main_env</span> <span class="n">comm_main_env</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
  <span class="n">paracel</span><span class="o">::</span><span class="n">Comm</span> <span class="n">comm</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
  <span class="n">google</span><span class="o">::</span><span class="n">SetUsageMessage</span><span class="p">(</span><span class="s">"[options]</span><span class="se">\n\t</span><span class="s">--server_info</span><span class="se">\n\t</span><span class="s">--cfg_file</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">google</span><span class="o">::</span><span class="n">ParseCommandLineFlags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">output</span> <span class="o">=</span> <span class="s">"/nfs/tmp/demo/"</span><span class="p">;</span>
  <span class="p">{</span>
    <span class="n">paracel</span><span class="o">::</span><span class="n">paralg</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">paracel</span><span class="o">::</span><span class="n">paralg</span><span class="p">(</span><span class="n">comm</span><span class="p">);</span>
    <span class="k">delete</span> <span class="n">pt</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">{</span>
    <span class="n">foo</span> <span class="n">solver</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">FLAGS_server_info</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>

<h3 id="paralg(paracel::comm-comm,-std::string-output-=-&quot;&quot;,-int-rounds-=-1);">paralg(paracel::Comm comm, std::string output = &ldquo;&rdquo;, int rounds = 1);</h3>

<p><em>Constructor: for direct use. <code class="prettyprint">comm</code> refer to the worker communicator, <code class="prettyprint">output</code> refer to the output folder for dumping results, <code class="prettyprint">rounds</code> refer to the traverse count of the total dataset.</em></p>

<h3 id="paralg(std::string-hosts_dct_str,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;paracel::comm-comm,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;std::string-output-=-&quot;&quot;,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;int-rounds-=-1,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;int-limit_s-=-0,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool-ssp_switch-=-false);">paralg(std::string hosts_dct_str,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;paracel::Comm comm,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;std::string output = &ldquo;&rdquo;,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;int rounds = 1,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;int limit_s = 0,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool ssp_switch = false);</h3>

<p><em>Constructor: for subclassing <code class="prettyprint">paralg</code> use. <code class="prettyprint">hosts_dct_str</code> is internal connect information which you will get from the main function, <code class="prettyprint">comm</code> refer to the worker communicator, <code class="prettyprint">output</code> refer to the output folder for dumping results, <code class="prettyprint">rounds</code> refer to the traverse count of the total dataset, <code class="prettyprint">limit_s</code> and <code class="prettyprint">ssp_switch</code> are used for <a href="#asynchronous-controlling">Asynchronous Controlling</a> in iterative tasks. <code class="prettyprint">output</code>, <code class="prettyprint">rounds</code>, <code class="prettyprint">limit_s</code> and <code class="prettyprint">ssp_switch</code> are default parameters, you do not need to define them.</em></p>

<aside class="success">
Remember
<p>
<p> - With passing into `output` argument, Paracel will create a new folder if not exist.
<p> - You do not need to know what the variable `hosts_dct_str` really means, you just need to get it from the main function and use it to initialize the constructor.
</aside>

<h2 id="load">Load</h2>
<pre><code class="highlight cpp"><span class="cp">#include &lt;google/gflags.h&gt;
#include "ps.hpp"
#include "utils.hpp"
#include "graph.hpp"
</span>
<span class="k">class</span> <span class="nc">foo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">paracel</span><span class="o">::</span><span class="n">paralg</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">foo</span><span class="p">(</span><span class="n">paracel</span><span class="o">::</span><span class="n">Comm</span> <span class="n">comm</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">hosts_dct_str</span><span class="p">)</span> <span class="o">:</span> <span class="n">paracel</span><span class="o">::</span><span class="n">paralg</span><span class="p">(</span><span class="n">hosts_dct_str</span><span class="p">,</span> <span class="n">comm</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">load_demo1</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">total_sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">line_list</span> <span class="o">=</span> <span class="n">paracel_loadall</span><span class="p">(</span><span class="s">"./data/*.csv"</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="n">line</span> <span class="o">:</span> <span class="n">line_lst</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">total_sz</span> <span class="o">+=</span> <span class="n">line</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">load_demo2</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">total_sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">handle_lambda</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">lines</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="n">line</span> <span class="o">:</span> <span class="n">lines</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">total_sz</span> <span class="o">+=</span> <span class="n">line</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">};</span>
    <span class="n">paracel_sequential_loadall</span><span class="p">(</span><span class="s">"./data/*.csv"</span><span class="p">,</span> <span class="n">handle_lambda</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">load_demo3</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">files</span> <span class="o">=</span> <span class="p">{</span><span class="n">data1</span><span class="p">.</span><span class="n">csv</span><span class="p">,</span> <span class="n">data2</span><span class="p">.</span><span class="n">csv</span><span class="p">};</span>
    <span class="kt">size_t</span> <span class="n">local_sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">local_line_list</span> <span class="o">=</span> <span class="n">paracel_load</span><span class="p">(</span><span class="n">files</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="n">line</span> <span class="o">:</span> <span class="n">local_line_list</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">local_sz</span> <span class="o">+=</span> <span class="n">line</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">load_demo4</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">files</span> <span class="o">=</span> <span class="p">{</span><span class="n">data1</span><span class="p">.</span><span class="n">csv</span><span class="p">,</span> <span class="n">data2</span><span class="p">.</span><span class="n">csv</span><span class="p">};</span>
    <span class="kt">size_t</span> <span class="n">local_sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">paracel_load_handle</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">line</span><span class="p">)</span> <span class="p">{</span> <span class="n">local_sz</span> <span class="o">+=</span> <span class="n">line</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">});</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">load_demo5</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">paracel</span><span class="o">::</span><span class="n">digraph</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">G1</span><span class="p">;</span>
    <span class="n">paracel</span><span class="o">::</span><span class="n">bigraph</span><span class="o">&lt;</span><span class="n">paracel</span><span class="o">::</span><span class="n">default_id_type</span><span class="o">&gt;</span> <span class="n">G2</span><span class="p">;</span>
    <span class="n">paracel</span><span class="o">::</span><span class="n">bigraph_continuous</span> <span class="n">G3</span><span class="p">;</span>

    <span class="cm">/*
     * graph1.txt     graph2.txt
     * 100,1,1          a,b
     * 100,3,2          a,c
     * 101,4,3          b,d
     * 102,1,2          c,a
     * ...            ...
     * ...            ...
     */</span>
    <span class="k">auto</span> <span class="n">local_parser</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">line</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">paracel</span><span class="o">::</span><span class="n">str_split</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="sc">','</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="c1">// you have to wrap your pre-defined functor with paracel::gen_parser
</span>    <span class="k">auto</span> <span class="n">f_parser</span> <span class="o">=</span> <span class="n">paracel</span><span class="o">::</span><span class="n">gen_parser</span><span class="p">(</span><span class="n">local_parser</span><span class="p">);</span>

    <span class="n">paracel_load_as_graph</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="s">"graph2.txt"</span><span class="p">,</span> <span class="n">f_parser</span><span class="p">,</span> <span class="s">"fmap"</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">paracel_load_as_graph</span><span class="p">(</span><span class="n">G2</span><span class="p">,</span> <span class="s">"graph1.txt"</span><span class="p">,</span> <span class="n">f_parser</span><span class="p">,</span> <span class="s">"smap"</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">paracel</span><span class="o">::</span><span class="n">default_id_type</span><span class="p">,</span>
                <span class="n">paracel</span><span class="o">::</span><span class="n">default_id_type</span><span class="o">&gt;</span> <span class="n">row_map</span><span class="p">,</span> <span class="n">col_map</span><span class="p">;</span>
    <span class="n">paracel_load_as_graph</span><span class="p">(</span><span class="n">G3</span><span class="p">,</span> <span class="n">row_map</span><span class="p">,</span> <span class="n">col_map</span><span class="p">,</span> <span class="s">"graph1.txt"</span><span class="p">,</span> <span class="n">f_parser</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">load_demo6</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">RowMajor</span><span class="o">&gt;</span> <span class="n">blk_mtx1</span><span class="p">,</span> <span class="n">blk_mtx2</span><span class="p">,</span> <span class="n">blk_mtx3</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">paracel</span><span class="o">::</span><span class="n">default_id_type</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">row_map</span><span class="p">,</span> <span class="n">col_map</span><span class="p">;</span>
    <span class="cm">/*
     * matrix1.txt      matrix2.txt
     * a,b,1        a 1.1,2.1,3.1,4.1
     * a,c,2        b 1.2,2.2,3.2,4.2
     * b,d,3        c 1.3,2.3,3.3,4.3
     * c,a,2        d 1.4,2.4,3.4,4.4
     * ...
     * ...
     */</span>
    <span class="k">auto</span> <span class="n">local_parser</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">line</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">paracel</span><span class="o">::</span><span class="n">str_split</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="sc">','</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="c1">// you have to wrap your pre-defined functor with paracel::gen_parser
</span>    <span class="k">auto</span> <span class="n">f_parser</span> <span class="o">=</span> <span class="n">paracel</span><span class="o">::</span><span class="n">gen_parser</span><span class="p">(</span><span class="n">local_parser</span><span class="p">);</span>

    <span class="n">paracel_load_as_matrix</span><span class="p">(</span><span class="n">blk_mtx1</span><span class="p">,</span> <span class="n">row_map</span><span class="p">,</span> <span class="n">col_map</span><span class="p">,</span>
                            <span class="s">"matrix1.txt"</span><span class="p">,</span> <span class="n">f_parser</span><span class="p">,</span> <span class="s">"fmap"</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">paracel_load_as_matrix</span><span class="p">(</span><span class="n">blk_mtx2</span><span class="p">,</span> <span class="n">row_map</span><span class="p">,</span> <span class="s">"matrix1.txt"</span><span class="p">,</span> <span class="n">f_parser</span><span class="p">,</span> <span class="s">"fmap"</span><span class="p">);</span>
    <span class="n">paracel_load_as_matrix</span><span class="p">(</span><span class="n">blk_mtx3</span><span class="p">,</span> <span class="s">"matrix1.txt"</span><span class="p">,</span> <span class="n">f_parser</span><span class="p">,</span> <span class="s">"fmap"</span><span class="p">);</span>

    <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">blk_dense_mtx1</span><span class="p">,</span> <span class="n">blk_dense_mtx2</span><span class="p">;</span>
    <span class="n">paracel_load_as_matrix</span><span class="p">(</span><span class="n">blk_dense_mtx1</span><span class="p">,</span> <span class="n">row_map</span><span class="p">,</span>
                            <span class="s">"matrix2.txt"</span><span class="p">,</span> <span class="n">f_parser</span><span class="p">);</span>
    <span class="n">paracel_load_as_matrix</span><span class="p">(</span><span class="n">blk_dense_mtx2</span><span class="p">,</span> <span class="s">"matrix2.txt"</span><span class="p">,</span> <span class="n">f_parser</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">solve</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// paracel_loadall interface usage
</span>    <span class="n">load_demo1</span><span class="p">();</span>
    <span class="c1">// paracel_sequential_loadall interface usage
</span>    <span class="n">load_demo2</span><span class="p">();</span>
    <span class="c1">// paracel_load interface usage
</span>    <span class="n">load_demo3</span><span class="p">();</span>
    <span class="c1">// paracel_load_handle interface usage
</span>    <span class="n">load_demo4</span><span class="p">();</span>
    <span class="c1">// paracel_load_as_graph interface usage
</span>    <span class="n">load_demo5</span><span class="p">();</span>
    <span class="c1">// paracel_load_as_matrix interface usage
</span>    <span class="n">load_demo6</span><span class="p">();</span>
  <span class="p">}</span>

<span class="p">};</span>

<span class="n">DEFINE_string</span><span class="p">(</span><span class="n">server_info</span><span class="p">,</span>
              <span class="s">"host1:7777PARACELhost2:8888"</span><span class="p">,</span>
              <span class="s">"hosts name string of paracel-servers.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">paracel</span><span class="o">::</span><span class="n">main_env</span> <span class="n">comm_main_env</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
  <span class="n">paracel</span><span class="o">::</span><span class="n">Comm</span> <span class="n">comm</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
  <span class="n">google</span><span class="o">::</span><span class="n">SetUsageMessage</span><span class="p">(</span><span class="s">"[options]</span><span class="se">\n\t</span><span class="s">--server_info</span><span class="se">\n\t</span><span class="s">--cfg_file</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">google</span><span class="o">::</span><span class="n">ParseCommandLineFlags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
  <span class="n">foo</span> <span class="n">solver</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">FLAGS_server_info</span><span class="p">);</span>
  <span class="n">solver</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>

<p>Paracel provides various interfaces for loading input files. In this version, all load related interfaces only support text format files so that it will cost a little more memory. You can either read a partition lines of data parallelly then construct customized data structure or directly load input data as the Paracel&rsquo;s <code class="prettyprint">graph</code> or <code class="prettyprint">matrix</code> types. In the latter case, you have to use <code class="prettyprint">pattern</code> and <code class="prettyprint">mix_flag</code> variables to describe the structure of the input files. <code class="prettyprint">Pattern</code> also decide the partition method for input data.</p>

<p>Paracel defines several patterns with variable <code class="prettyprint">pattern</code>:</p>

<table><thead>
<tr>
<th>pattern</th>
<th>structure</th>
<th>line example</th>
</tr>
</thead><tbody>
<tr>
<td>linesplit(default)</td>
<td>partition with lines</td>
<td>all structures</td>
</tr>
<tr>
<td>fmap</td>
<td>first-second case(value set to 1.0)<br>first-second-value case<br>partition with the first field</td>
<td>a,b<br>a,b,0.2</td>
</tr>
<tr>
<td>smap</td>
<td>second-first case(value set to 1.0)<br>second-first-value case<br>partition with the second field</td>
<td>a,b<br>a,b,0.2</td>
</tr>
<tr>
<td>fsmap</td>
<td>support the same structure as fmap and smap<br>2D partition</td>
<td>a,b or a,b,0.2</td>
</tr>
<tr>
<td>fvec</td>
<td>id,feature1,&hellip;,featurek case<br>partition with id</td>
<td>1001 0.1&#124;0.2&#124;0.3&#124;0.4</td>
</tr>
<tr>
<td>fset</td>
<td>attr1,attr2,attr3,&hellip;<br>attr1,attr2&#124;value2,attr3&#124;value3,&hellip;<br>partition with the first field</td>
<td>a,b,c or a,b&#124;0.2,c&#124;0.4</td>
</tr>
</tbody></table>

<p>Variable <code class="prettyprint">mix_flag</code> represents whether linking relation of a graph/matrix is defined in a single line. As you can see the example below, when <code class="prettyprint">mix_flag</code> is set to false, all the linking relation of node &lsquo;a&rsquo; is expanded in three single lines. If <code class="prettyprint">pattern</code> equals to <code class="prettyprint">fvec</code> and <code class="prettyprint">fset</code>, <code class="prettyprint">mix_flag</code> is always <code class="prettyprint">true</code>.</p>

<table><thead>
<tr>
<th>mix_flag</th>
<th>example</th>
</tr>
</thead><tbody>
<tr>
<td>true</td>
<td>a,b,c,d<br>b,c,d<br>&hellip;</td>
</tr>
<tr>
<td>true</td>
<td>a,b<br>a,c,d<br>b,c<br>b,d<br>&hellip;</td>
</tr>
<tr>
<td>false(default)</td>
<td>a,b<br>a,c<br>a,d<br>b,c<br>b,d<br>&hellip;</td>
</tr>
</tbody></table>

<p>As you can see above, <code class="prettyprint">pattern</code> do not only decide data format but also decide partition strategy while <code class="prettyprint">mix_flag</code> tell Paracel if a link relation is mixed in a single line.</p>

<h3 id="template&lt;class-t&gt;vector&lt;string&gt;-paracel_loadall(const-t-&amp;-fn);">template&lt;class T&gt;<br>vector&lt;string&gt; paracel_loadall(const T &amp; fn);</h3>

<p><em>Each worker load all lines in <code class="prettyprint">fn</code>. <code class="prettyprint">T</code> can be either string type to represent one file or vector&lt;string&gt; to represent a set of files. See more details on the right.</em></p>

<h3 id="template&lt;class-t,-class-f&gt;void-paracel_sequential_loadall(const-t-&amp;-fn,-f-&amp;-func);">template&lt;class T, class F&gt;<br>void paracel_sequential_loadall(const T &amp; fn, F &amp; func);</h3>

<p><em>Each worker load all lines in <code class="prettyprint">fn</code> and handle with functor <code class="prettyprint">func</code>. To avoid memory exceed, we recommend you to use this interface. Paracel will load part of lines in <code class="prettyprint">fn</code> and call <code class="prettyprint">func</code> to handle them, then do it again and again until the end of <code class="prettyprint">fn</code>. <code class="prettyprint">T</code> can be either string type to represent one file or vector&lt;string&gt; to represent a set of files. See more details on the right.</em></p>

<h3 id="template&lt;class-t&gt;vector-paracel_load(const-t-&amp;-fn);">template&lt;class T&gt;<br>vector<string> paracel_load(const T &amp; fn);</h3>

<p><em>SPMD interface: each worker load <code class="prettyprint">fn</code>&rsquo;s lines parallelly. <code class="prettyprint">T</code> can be either string type to represent one file or vector&lt;string&gt; to represent a set of files. See more details on the right.</em></p>

<h3 id="template&lt;class-t,-class-f&gt;void-paracel_load_handle(const-t-&amp;-fn,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;f-&amp;-func,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-string-&amp;-pattern-=-&quot;linesplit&quot;,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool-mix_flag-=-false);">template&lt;class T, class F&gt;<br>void paracel_load_handle(const T &amp; fn,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;F &amp; func,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const string &amp; pattern = &ldquo;linesplit&rdquo;,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool mix_flag = false);</h3>

<p><em>SPMD interface: parallelly load <code class="prettyprint">fn</code> and handle with <code class="prettyprint">func</code> line by line. <code class="prettyprint">func</code> takes string type as argument and Paracel will pass each line of <code class="prettyprint">fn</code> as input parameter. You can also specify <code class="prettyprint">pattern</code> and <code class="prettyprint">mix_flag</code> to describe the structure of <code class="prettyprint">fn</code>. <code class="prettyprint">T</code> can be either string type to represent one file or vector&lt;string&gt; to represent a set of files. See more details on the right.</em></p>

<h3 id="template&lt;class-t,-class-g&gt;void-paracel_load_as_graph(paracel::digraph&lt;g&gt;-&amp;-grp,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-t-&amp;-fn,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;parser_type-&amp;-parser,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::string-pattern-=-&quot;fmap&quot;,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool-mix_flag-=-false);">template&lt;class T, class G&gt;<br>void paracel_load_as_graph(paracel::digraph&lt;G&gt; &amp; grp,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const T &amp; fn,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;parser_type &amp; parser,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::string pattern = &ldquo;fmap&rdquo;,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool mix_flag = false);</h3>

<p><em>SPMD interface: parallelly load <code class="prettyprint">fn</code> using <code class="prettyprint">parser</code> and then generate local <a href="#digraph">digraph</a> <code class="prettyprint">grp</code> for each worker. Input argument of <code class="prettyprint">parser</code> must be string type and it must return vector&lt;string&gt; type which refer to the fields of this digraph. You can also specify <code class="prettyprint">pattern</code> and <code class="prettyprint">mix_flag</code> to describe the structure of <code class="prettyprint">fn</code>. <code class="prettyprint">T</code> can be either string type to represent one file or vector&lt;string&gt; to represent a set of files. See more details on the right.</em></p>

<h3 id="template&lt;class-t,-class-g&gt;void-paracel_load_as_graph(paracel::bigraph&lt;g&gt;-&amp;-grp,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-t-&amp;-fn,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;parser_type-&amp;-parser,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::string-pattern-=-&quot;fmap&quot;,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool-mix_flag-=-false);">template&lt;class T, class G&gt;<br>void paracel_load_as_graph(paracel::bigraph&lt;G&gt; &amp; grp,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const T &amp; fn,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;parser_type &amp; parser,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::string pattern = &ldquo;fmap&rdquo;,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool mix_flag = false);</h3>

<p><em>SPMD interface: parallelly load <code class="prettyprint">fn</code> using <code class="prettyprint">parser</code> and then generate local <a href="#bigraph">bigraph</a> <code class="prettyprint">grp</code> for each worker. Input argument of <code class="prettyprint">parser</code> must be string type and it must return vector&lt;string&gt; type which refer to the fields of this bigraph. You can also specify <code class="prettyprint">pattern</code> and <code class="prettyprint">mix_flag</code> to describe the structure of <code class="prettyprint">fn</code>. <code class="prettyprint">T</code> can be either string type to represent one file or vector&lt;string&gt; to represent a set of files. See more details on the right.</em></p>

<h3 id="template&lt;class-t&gt;void-paracel_load_as_graph(paracel::bigraph_continuous-&amp;-grp,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;unordered_map&lt;default_id_type,-default_id_type&gt;-&amp;-row_map,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;unordered_map&lt;default_id_type,-default_id_type&gt;-&amp;-col_map,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-t-&amp;-fn,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;parser_type-&amp;-parser,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-string-&amp;-pattern-=-&quot;fmap&quot;,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool-mix_flag-=-false);">template&lt;class T&gt;<br>void paracel_load_as_graph(paracel::bigraph_continuous &amp; grp,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;unordered_map&lt;default_id_type, default_id_type&gt; &amp; row_map,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;unordered_map&lt;default_id_type, default_id_type&gt; &amp; col_map,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const T &amp; fn,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;parser_type &amp; parser,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const string &amp; pattern = &ldquo;fmap&rdquo;,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool mix_flag = false);</h3>

<p><em>SPMD interface: parallelly load <code class="prettyprint">fn</code> using <code class="prettyprint">parser</code> and then generate local <a href="#bigraph_continuous">bigraph_continuous</a> <code class="prettyprint">grp</code> for each worker. Since Paracel will map original ids into continuous indexes, this interface has two more output arguments to tell the mapping infomation: <code class="prettyprint">row_map</code> and <code class="prettyprint">col_map</code>. <code class="prettyprint">row_map</code> or <code class="prettyprint">col_map</code> store the corresponding relation between <code class="prettyprint">paracel::default_id_type</code> and generic type <code class="prettyprint">G</code> of graph node. Input argument of <code class="prettyprint">parser</code> must be string type and it must return vector&lt;string&gt; type which refer to the fields of this bigraph_continuous. You can also specify <code class="prettyprint">pattern</code> and <code class="prettyprint">mix_flag</code> to describe the structure of <code class="prettyprint">fn</code>. <code class="prettyprint">T</code> can be either string type to represent one file or vector&lt;string&gt; to represent a set of files. See more details on the right.</em></p>

<h3 id="template&lt;class-t,-class-g&gt;void-paracel_load_as_matrix(eigen::sparsematrix&lt;double,-eigen::rowmajor&gt;-&amp;-blk_mtx,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;std::unordered_map&lt;default_id_type,-g&gt;-&amp;-row_map,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;std::unordered_map&lt;default_id_type,-g&gt;-&amp;-col_map,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-t-&amp;-fn,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;parser_type-&amp;-parser,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::string-&amp;-pattern-=-&quot;fsmap&quot;,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool-mix_flag-=-false);">template&lt;class T, class G&gt;<br>void paracel_load_as_matrix(Eigen::SparseMatrix&lt;double, Eigen::RowMajor&gt; &amp; blk_mtx,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;std::unordered_map&lt;default_id_type, G&gt; &amp; row_map,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;std::unordered_map&lt;default_id_type, G&gt; &amp; col_map,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const T &amp; fn,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;parser_type &amp; parser,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::string &amp; pattern = &ldquo;fsmap&rdquo;,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool mix_flag = false);</h3>

<p><em>SPMD interface: parallelly load <code class="prettyprint">fn</code> using <code class="prettyprint">parser</code> and then generate block <a href="#sparsematrix">Eigen::SparseMatrix</a> <code class="prettyprint">blk_mtx</code> for each worker. Since indexes of a matrix must be continuous, Paracel will map original ids into continuous indexes. There are two more output arguments to store the mapping infomation: <code class="prettyprint">row_map</code> and <code class="prettyprint">col_map</code>. <code class="prettyprint">row_map</code> or <code class="prettyprint">col_map</code> store the corresponding relation between <code class="prettyprint">paracel::default_id_type</code> and generic type <code class="prettyprint">G</code> of Eigen::SparseMatrix. Input argument of <code class="prettyprint">parser</code> must be string type and it must return vector&lt;string&gt; type. You can also specify <code class="prettyprint">pattern</code> and <code class="prettyprint">mix_flag</code> to describe the structure of <code class="prettyprint">fn</code>. <code class="prettyprint">T</code> can be either string type to represent one file or vector&lt;string&gt; to represent a set of files. See more details on the right.</em></p>

<h3 id="template&lt;class-t,-class-g&gt;void-paracel_load_as_matrix(eigen::sparsematrix&lt;double,-eigen::rowmajor&gt;-&amp;-blk_mtx,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;std::unordered_map&lt;default_id_type,-g&gt;-&amp;-row_map,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-t-&amp;-fn,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;parser_type-&amp;-parser,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::string-&amp;-pattern-=-&quot;fsmap&quot;,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool-mix_flag-=-false);">template&lt;class T, class G&gt;<br>void paracel_load_as_matrix(Eigen::SparseMatrix&lt;double, Eigen::RowMajor&gt; &amp; blk_mtx,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;std::unordered_map&lt;default_id_type, G&gt; &amp; row_map,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const T &amp; fn,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;parser_type &amp; parser,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::string &amp; pattern = &ldquo;fsmap&rdquo;,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool mix_flag = false);</h3>

<p><em>Similar interface as the previous one without <code class="prettyprint">col_map</code>. See more details on the right.</em></p>

<h3 id="template&lt;class-t,-class-g&gt;void-paracel_load_as_matrix(eigen::sparsematrix&lt;double,-eigen::rowmajor&gt;-&amp;-blk_mtx,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-t-&amp;-fn,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;parser_type-&amp;-parser,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::string-&amp;-pattern-=-&quot;fsmap&quot;,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool-mix_flag-=-false);">template&lt;class T, class G&gt;<br>void paracel_load_as_matrix(Eigen::SparseMatrix&lt;double, Eigen::RowMajor&gt; &amp; blk_mtx,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const T &amp; fn,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;parser_type &amp; parser,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::string &amp; pattern = &ldquo;fsmap&rdquo;,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool mix_flag = false);</h3>

<p><em>Similar interface as the previous one without <code class="prettyprint">row_map</code> and <code class="prettyprint">col_map</code>. See more details on the right.</em></p>

<h3 id="template&lt;class-t,-class-g&gt;void-paracel_load_as_matrix(eigen::matrixxd-&amp;-blk_dense_mtx,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;std::unordered_map&lt;default_id_type,-g&gt;-&amp;-row_map,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-t-&amp;-fn,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;parser_type-&amp;-parser);">template&lt;class T, class G&gt;<br>void paracel_load_as_matrix(Eigen::MatrixXd &amp; blk_dense_mtx,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;std::unordered_map&lt;default_id_type, G&gt; &amp; row_map,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const T &amp; fn,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;parser_type &amp; parser);</h3>

<p><em>SPMD interface: parallelly load <code class="prettyprint">fn</code> using <code class="prettyprint">parser</code> and then generate block <a href="#dense-matrix">Eigen::MatrixXD</a> <code class="prettyprint">blk_dense_mtx</code> for each worker. Since indexes of a matrix must be continuous, Paracel will map original ids into continuous indexes. The output arguments <code class="prettyprint">row_map</code> is used to store the corresponding relation between <code class="prettyprint">paracel::default_id_type</code> and generic type <code class="prettyprint">G</code> of Eigen::MatrixXd. Input argument of <code class="prettyprint">parser</code> must be string type and it must return vector&lt;string&gt; type. File structure in this case can be only <code class="prettyprint">fvec</code>. <code class="prettyprint">T</code> can be either string type to represent one file or vector&lt;string&gt; to represent a set of files. See more details on the right.</em></p>

<h3 id="template&lt;class-t,-class-g&gt;void-paracel_load_as_matrix(eigen::matrixxd-&amp;-blk_dense_mtx,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-t-&amp;-fn,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;parser_type-&amp;-parser);">template&lt;class T, class G&gt;<br>void paracel_load_as_matrix(Eigen::MatrixXd &amp; blk_dense_mtx,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const T &amp; fn,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;parser_type &amp; parser);</h3>

<p><em>Similar interface as the previous one without <code class="prettyprint">row_map</code>. See more details on the right.</em></p>

<aside class="success">
Remember
<p>
<p> - <b>fn</b> above can be a regular expression.
</aside>

<h2 id="communication">Communication</h2>
<pre><code class="highlight cpp">
<span class="cp">#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;google/gflags.h&gt;
#include "ps.hpp"
#include "utils.hpp"
</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">foo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">paracel</span><span class="o">::</span><span class="n">pralg</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">foo</span><span class="p">(</span><span class="n">paracel</span><span class="o">::</span><span class="n">Comm</span> <span class="n">comm</span><span class="p">,</span> <span class="n">string</span> <span class="n">hosts_dct_str</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">paracel</span><span class="o">::</span><span class="n">paralg</span><span class="p">(</span><span class="n">hosts_dct_str</span><span class="p">,</span> <span class="n">comm</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">test_register</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">paracel_register_update</span><span class="p">(</span>
                <span class="s">"/nfs/lib/paracel/libupdate.so"</span><span class="p">,</span>
                <span class="s">"sum_updater"</span><span class="p">);</span>
    <span class="n">paracel_register_bupdate</span><span class="p">(</span>
                <span class="s">"/nfs/lib/paracel/libupdate.so"</span><span class="p">,</span>
                <span class="s">"sum_updater"</span><span class="p">);</span>
    <span class="n">paracel_register_read_special</span><span class="p">(</span>
                <span class="s">"/nfs/lib/paracel/lib/libfilter.so"</span><span class="p">,</span>
                <span class="s">"key_filter"</span><span class="p">);</span>

  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">test_push</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">get_worker_id</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">paracel_write</span><span class="p">(</span><span class="s">"key1"</span><span class="p">,</span> <span class="s">"value"</span><span class="p">);</span>
      <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">;</span>
      <span class="n">d</span><span class="p">[</span><span class="s">"key2"</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.</span><span class="p">;</span> <span class="n">d</span><span class="p">[</span><span class="s">"key3"</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.</span><span class="p">;</span>
      <span class="n">d</span><span class="p">[</span><span class="s">"doc_key4"</span><span class="p">]</span> <span class="o">=</span> <span class="mf">5.</span><span class="p">;</span>
      <span class="n">d</span><span class="p">[</span><span class="s">"key5"</span><span class="p">]</span> <span class="o">=</span> <span class="mf">6.</span><span class="p">;</span> <span class="n">d</span><span class="p">[</span><span class="s">"key6"</span><span class="p">]</span> <span class="o">=</span> <span class="mf">7.</span><span class="p">;</span>
      <span class="n">paracel_write_multi</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">test_pull</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">paracel_read</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"key1"</span><span class="p">);</span> <span class="c1">// "value"
</span>    <span class="kt">double</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">paracel_read</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"key2"</span><span class="p">);</span> <span class="c1">// 3.
</span>    <span class="kt">double</span> <span class="n">r3</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">paracel_read</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"key3"</span><span class="p">,</span> <span class="n">r3</span><span class="p">);</span> <span class="c1">// r3 = 4., f1 = true
</span>    <span class="n">bool</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">paracel_read</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"key10"</span><span class="p">,</span> <span class="n">r3</span><span class="p">);</span> <span class="c1">// f2 = false
</span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">keys_list</span> <span class="o">=</span> <span class="p">{</span><span class="s">"key5"</span><span class="p">,</span> <span class="s">"key6"</span><span class="p">};</span>

    <span class="c1">// { 6., 7. }
</span>    <span class="k">auto</span> <span class="n">val_list</span> <span class="o">=</span> <span class="n">paracel_read_multi</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">keys_list</span><span class="p">);</span>

    <span class="c1">// compile error since there contains string-type-value
</span>    <span class="k">auto</span> <span class="n">rr</span> <span class="o">=</span> <span class="n">paracel_readall</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">special_read_handle_lambda</span> <span class="o">=</span>
    <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="n">kv</span> <span class="o">:</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">kv</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">// compile error since there contains string-type-value
</span>    <span class="n">paracel_readall_handle</span><span class="p">(</span><span class="n">special_read_handle_lambda</span><span class="p">);</span>

    <span class="c1">// compile error since there contains stirng-type-value
</span>    <span class="k">auto</span> <span class="n">rrr</span> <span class="o">=</span> <span class="n">paracel_read_special</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span>
                        <span class="s">"/nfs/lib/libfilter.so"</span><span class="p">,</span>
                        <span class="s">"key_filter"</span><span class="p">);</span>

    <span class="c1">// result = 5.
</span>    <span class="n">paracel_read_special_handle</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span>
                    <span class="s">"/nfs/lib/libfilter.so"</span><span class="p">,</span>
                    <span class="s">"key_filter"</span><span class="p">,</span>
                    <span class="n">special_read_handle_lambda</span><span class="p">);</span>

  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">test_update</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">paracel</span><span class="o">::</span><span class="n">async_functor_type</span> <span class="n">future1</span><span class="p">,</span> <span class="n">future2</span><span class="p">,</span> <span class="n">future3</span><span class="p">;</span>
    <span class="n">paracel_update</span><span class="p">(</span><span class="s">"key5"</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="n">future1</span><span class="p">);</span> <span class="c1">// update with registered "sum_updater"
</span>    <span class="n">paracel_update</span><span class="p">(</span><span class="s">"key5"</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="n">future2</span><span class="p">);</span>
    <span class="c1">// key doesn't exist, following code equals to paracel_write
</span>    <span class="n">paracel_update</span><span class="p">(</span><span class="s">"new_key1"</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span><span class="n">future3</span><span class="p">);</span>
    <span class="c1">// do some computation here, parallel with sum_updater
</span>    <span class="k">if</span><span class="p">(</span><span class="n">paracel</span><span class="o">::</span><span class="n">wait</span><span class="p">(</span><span class="n">future1</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"33.3%"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">paracel</span><span class="o">::</span><span class="n">wait</span><span class="p">(</span><span class="n">future2</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"66.6%"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">paracel</span><span class="o">::</span><span class="n">wait</span><span class="p">(</span><span class="n">future3</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"100%"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">test_bupdate</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">get_worker_id</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">paracel_bupdate</span><span class="p">(</span><span class="s">"key2"</span><span class="p">,</span> <span class="mf">7.</span><span class="p">);</span> <span class="c1">// bupdate with registered "sum_updater"
</span>      <span class="c1">// specify another update function instead of the registered one
</span>      <span class="n">paracel_bupdate</span><span class="p">(</span><span class="s">"key3"</span><span class="p">,</span> <span class="mf">6.</span><span class="p">,</span>
            <span class="s">"/nfs/lib/paracel/libupdate.so"</span><span class="p">,</span>
            <span class="s">"sum_updater2"</span><span class="p">);</span>

      <span class="c1">// key doesn't exist, following code equals to paracel_write
</span>      <span class="n">paracel_bupdate</span><span class="p">(</span><span class="s">"new_key2"</span><span class="p">,</span> <span class="mf">1.</span><span class="p">);</span>

      <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">keys</span> <span class="o">=</span> <span class="p">{</span><span class="s">"key2"</span><span class="p">,</span> <span class="s">"key3"</span><span class="p">,</span> <span class="s">"key5"</span><span class="p">};</span>
      <span class="n">paracel_bupdate_multi</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">deltas</span><span class="p">,</span>
                <span class="s">"/nfs/lib/paracel/libupdate.so"</span><span class="p">,</span>
                <span class="s">"sum_updater2"</span><span class="p">);</span>

      <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">;</span>
      <span class="n">d</span><span class="p">[</span><span class="s">"key2"</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="n">d</span><span class="p">[</span><span class="s">"key3"</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="n">d</span><span class="p">[</span><span class="s">"key5"</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span>
      <span class="n">paracel_bupdate_multi</span><span class="p">(</span><span class="n">d</span><span class="p">,</span>
                    <span class="s">"/nfs/lib/paracel/libupdate.so"</span><span class="p">,</span>
                    <span class="s">"sum_updater2"</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">solve</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">test_register</span><span class="p">();</span>
    <span class="n">paracel_sync</span><span class="p">();</span>

    <span class="n">test_push</span><span class="p">();</span>
    <span class="n">paracel_sync</span><span class="p">();</span>

    <span class="n">test_pull</span><span class="p">();</span>

    <span class="n">test_update</span><span class="p">();</span>

    <span class="n">test_bupdate</span><span class="p">();</span>
    <span class="n">paracel_sync</span><span class="p">();</span>
  <span class="p">}</span>

<span class="p">};</span>

<span class="n">DEFINE_string</span><span class="p">(</span><span class="n">server_info</span><span class="p">,</span>
    <span class="s">"host1:7777PARACELhost2:8888"</span><span class="p">,</span>
    <span class="s">"hosts name string of paracel-servers.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">paracel</span><span class="o">::</span><span class="n">main_env</span> <span class="n">comm_main_env</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
  <span class="n">paracel</span><span class="o">::</span><span class="n">Comm</span> <span class="n">comm</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
  <span class="n">google</span><span class="o">::</span><span class="n">SetUsageMessage</span><span class="p">(</span><span class="s">"[options]</span><span class="se">\n\t</span><span class="s">--server_info</span><span class="se">\n\t</span><span class="s">--cfg_file</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">google</span><span class="o">::</span><span class="n">ParseCommandLineFlags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
  <span class="n">foo</span> <span class="n">solver</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">FLAGS_server_info</span><span class="p">);</span>
  <span class="n">solver</span><span class="p">.</span><span class="n">solve</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>

<p>Paracel provides a distributed, global key-value store called parameter server. Parameter server is a novel paradigm, which will help you do information exchange much more easily. Messages in Paracel(also defined as parameters) must have a key-value structure. When doing communication, workers only need to interact with servers to read/write/update messages. Communication interfaces in Paracel are really simple and flexible.</p>

<h3 id="bool-paracel_register_update(const-std::string-&amp;-file_name,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::string-&amp;-func_name);">bool paracel_register_update(const std::string &amp; file_name,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::string &amp; func_name);</h3>

<p><em>Register <a href="#update-function">update function</a> into Paracel with specified <code class="prettyprint">file_name</code> and <code class="prettyprint">func_name</code>. Corresponding interface with <code class="prettyprint">paracel_update</code> and so on.</em></p>

<h3 id="bool-paracel_register_bupdate(const-std::string-&amp;-file_name,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::string-&amp;-func_name);">bool paracel_register_bupdate(const std::string &amp; file_name,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::string &amp; func_name);</h3>

<p><em>Register <a href="#update-function">update function</a> into Paracel with specified <code class="prettyprint">file_name</code> and <code class="prettyprint">func_name</code>. Corresponding interface with <code class="prettyprint">paracel_bupdate</code> and so on.</em></p>

<h3 id="bool-paracel_register_read_special(const-std::string-&amp;-file_name,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::string-&amp;-func_name);">bool paracel_register_read_special(const std::string &amp; file_name,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::string &amp; func_name);</h3>

<p><em>Register <a href="#filter-function">filter function</a> into Paracel with specified <code class="prettyprint">file_name</code> and <code class="prettyprint">func_name</code>. Corresponding interface with <code class="prettyprint">paracel_read_special</code> and so on.</em></p>

<h3 id="template&lt;class-v&gt;bool-paracel_read(const-std::string-&amp;-key,-v-&amp;-val);">template&lt;class V&gt;<br>bool paracel_read(const std::string &amp; key, V &amp; val);</h3>

<p><em>Pull <code class="prettyprint">val</code> from parameter server with specified <code class="prettyprint">key</code>. If <code class="prettyprint">key</code> does not exist, return false. Otherwise return true.</em></p>

<h3 id="template&lt;class-v&gt;v-paracel_read(const-std::string-&amp;-key);">template&lt;class V&gt;<br>V paracel_read(const std::string &amp; key);</h3>

<p><em>Pull <code class="prettyprint">val</code> from parameter server with specified <code class="prettyprint">key</code>. If <code class="prettyprint">key</code> does not exist, <code class="prettyprint">ERROR_ABORT</code> will be invoked.</em></p>

<h3 id="template&lt;class-v&gt;std::vector&lt;v&gt;paracel_read_multi(const-std::vector&lt;std::string&gt;-&amp;-keys);">template&lt;class V&gt;<br>std::vector&lt;V&gt;<br>paracel_read_multi(const std::vector&lt;std::string&gt; &amp; keys);</h3>

<p><em>Pull multiply values from parameter server in one-time. Input argument is a list of keys and return value is the corresponding value with these keys. Every key in <code class="prettyprint">keys</code> must exist.</em></p>

<h3 id="template&lt;class-v&gt;unordered_map&lt;string,-v&gt;-paracel_readall();">template&lt;class V&gt;<br>unordered_map&lt;string, V&gt; paracel_readall();</h3>

<p><em>Pull all key-value pairs from parameter server into an unordered_map.</em></p>

<h3 id="template&lt;class-v,-class-f&gt;void-paracel_readall_handle(f-&amp;-func);">template&lt;class V, class F&gt;<br>void paracel_readall_handle(F &amp; func);</h3>

<p><em>Pull all key-value pairs from parameter server in batches and handle with functor <code class="prettyprint">func</code>. It is similar interface with <code class="prettyprint">paracel_readall</code> while this one can avoid memory exceed problem in large parameter case.</em></p>

<h3 id="template&lt;class-v&gt;unordered_map&lt;string,-v&gt;paracel_read_special(const-std::string-&amp;-file_name,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::string-&amp;-func_name);">template&lt;class V&gt;<br>unordered_map&lt;string, V&gt;<br>paracel_read_special(const std::string &amp; file_name,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::string &amp; func_name);</h3>

<p><em>Pull key-value pairs from parameter server into an unordered_map with <a href="#filter-function">filter function</a>. The filter function is specified with <code class="prettyprint">file_name</code> and <code class="prettyprint">func_name</code>.</em></p>

<h3 id="template&lt;class-v,-class-f&gt;void-paracel_read_special_handle(const-std::string-&amp;-file_name,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::string-&amp;-func_name,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;f-&amp;-func);">template&lt;class V, class F&gt;<br>void paracel_read_special_handle(const std::string &amp; file_name,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::string &amp; func_name,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;F &amp; func);</h3>

<p><em>Pull key-value pairs from parameter server into an unordered_map in batches with handler <code class="prettyprint">func</code> and <a href="#filter-function">filter function</a>. The filter function is specified with <code class="prettyprint">file_name</code> and <code class="prettyprint">func_name</code>.</em></p>

<h3 id="template&lt;class-t&gt;void-paracel_read_topk(int-k,-vector&lt;pair&lt;string,-t&gt;-&gt;-&amp;-result);">template&lt;class T&gt;<br>void paracel_read_topk(int k, vector&lt;pair&lt;string, T&gt; &gt; &amp; result);</h3>

<p><em>Read topk key-value pairs(compare by value) from parameter server into a <code class="prettyprint">result</code> list.</em></p>

<h3 id="template&lt;class-t&gt;void-paracel_read_topk_with_key_filter(int-k,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;vector&lt;pair&lt;string,-t&gt;-&gt;-&amp;-result,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-string-&amp;-file_name,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-string-&amp;-func_name);">template&lt;class T&gt;<br>void paracel_read_topk_with_key_filter(int k,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;vector&lt;pair&lt;string, T&gt; &gt; &amp; result,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const string &amp; file_name,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const string &amp; func_name);</h3>

<p><em>Read topk key-value pairs(compare by value) from parameter server with <a href="#filter-function">filter function</a> into a <code class="prettyprint">result</code> list. The filter function is specified with <code class="prettyprint">file_name</code> and <code class="prettyprint">func_name</code>.</em></p>

<h3 id="template&lt;class-v&gt;bool-paracel_write(const-std::string-&amp;-key,-const-v-&amp;-val);">template&lt;class V&gt;<br>bool paracel_write(const std::string &amp; key, const V &amp; val);</h3>

<p><em>Push key-value pair into parameter server. <code class="prettyprint">paracel_write</code> is idempotent.</em></p>

<h3 id="template&lt;class-v&gt;bool-paracel_write_multi(const-unordered_map-&amp;-dct);">template&lt;class V&gt;<br>bool paracel_write_multi(const unordered_map<string, V> &amp; dct);</h3>

<p><em>Push key-value pairs into parameter server. <code class="prettyprint">paracel_write_multi</code> is idempotent.</em></p>

<h3 id="template&lt;class-v&gt;void-paracel_update(const-std::string-&amp;-key,-const-v-&amp;-delta,-&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;paracel::async_functor_type-&amp;-future);">template&lt;class V&gt;<br>void paracel_update(const std::string &amp; key, const V &amp; delta, <br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;paracel::async_functor_type &amp; future);</h3>

<p><em>Advanced interface! Update key&rsquo;s value with delta in parameter server. The function will be invoked for <code class="prettyprint">delta</code> with the update function specified in <code class="prettyprint">paracel_register_update</code>. It is a non-blocking interface which means after returning, the updating operation in the server end may or may not be finished. You can use <code class="prettyprint">paracel::wait(future)</code> to wait until the update occured in the server end, before invoking <code class="prettyprint">paracel::wait(future)</code>, you can do some computation at the same time. If you are not pursuing performance, we strongly recommend you to use <code class="prettyprint">paracel_bupdate</code> interface in most case to ensure the correctness of your algorithms.</em></p>

<h3 id="template&lt;class-v&gt;void-paracel_update(const-std::string-&amp;-key,-const-v-&amp;-delta,-&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::string-&amp;-file_name,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::string-&amp;-func_name,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;paracel::async_functor_type-&amp;-future);">template&lt;class V&gt;<br>void paracel_update(const std::string &amp; key, const V &amp; delta, <br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::string &amp; file_name,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::string &amp; func_name,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;paracel::async_functor_type &amp; future);</h3>

<p><em>Advanced interface! Update key&rsquo;s value with delta in parameter server. The function will be invoked for <code class="prettyprint">delta</code> with <code class="prettyprint">file_name</code> and <code class="prettyprint">func_name</code>. It is a non-blocking interface which means after returning, the updating operation in the server end may or may not be finished. You can use <code class="prettyprint">paracel::wait(future)</code> to wait until the update occured in the server end, before invoking <code class="prettyprint">paracel::wait(future)</code>, you can do some computation at the same time. If you are not pursuing performance, we strongly recommend you to use <code class="prettyprint">paracel_bupdate</code> interface in most case to ensure the correctness of your algorithms.</em></p>

<h3 id="template&lt;class-v&gt;bool-paracel_bupdate(const-std::string-&amp;-key,-const-v-&amp;-delta);">template&lt;class V&gt;<br>bool paracel_bupdate(const std::string &amp; key, const V &amp; delta);</h3>

<p><em>Block update key&rsquo;s value with delta in parameter server. The function will be invoked for <code class="prettyprint">delta</code> with the update function specified in <code class="prettyprint">paracel_register_bupdate</code>. It is a blocking interface which means after returning, the updating operation in the server end must be finished.</em></p>

<h3 id="template-&lt;class-v&gt;bool-paracel_bupdate(const-std::string-&amp;-key,-const-v-&amp;-delta,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::string-&amp;-file_name,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::string-&amp;-func_name);">template &lt;class V&gt;<br>bool paracel_bupdate(const std::string &amp; key, const V &amp; delta,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::string &amp; file_name,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::string &amp; func_name);</h3>

<p><em>Block update key&rsquo;s value with delta in parameter server. The function will be invoked for <code class="prettyprint">delta</code> with the update function specified by <code class="prettyprint">file_name</code> and <code class="prettyprint">func_name</code>. It is a blocking interface which means after returning, the updating operation in the server end must be finished.</em></p>

<h3 id="template-&lt;class-v&gt;bool-paracel_bupdate_multi(const-std::vector&lt;std::string&gt;-&amp;-keys,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::vector&lt;v&gt;-&amp;-deltas&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::string-&amp;-file_name,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::string-&amp;-func_name);">template &lt;class V&gt;<br>bool paracel_bupdate_multi(const std::vector&lt;std::string&gt; &amp; keys,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::vector&lt;V&gt; &amp; deltas<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::string &amp; file_name,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::string &amp; func_name);</h3>

<p><em>Block update key-value pairs in batches. You must specify the <a href="#update-function">update function</a> with <code class="prettyprint">file_name</code> and <code class="prettyprint">func_name</code>. <code class="prettyprint">deltas</code> size must be equal with <code class="prettyprint">keys</code> size.</em></p>

<h3 id="template-&lt;class-v&gt;bool-paracel_bupdate_multi(const-unordered_map-&amp;-dct,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::string-&amp;-file_name,-&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-std::string-&amp;-func_name);">template &lt;class V&gt;<br>bool paracel_bupdate_multi(const unordered_map<string, V> &amp; dct,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::string &amp; file_name, <br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const std::string &amp; func_name);</h3>

<p><em>Block update key-value pairs in batches. You must specify the <a href="#update-function">update function</a> with <code class="prettyprint">file_name</code> and <code class="prettyprint">func_name</code>. <code class="prettyprint">dct</code> refer to the unordered_map with key to delta.</em></p>

<h3 id="bool-paracel_contains(const-std::string-&amp;-key);">bool paracel_contains(const std::string &amp; key);</h3>

<p><em>Check if <code class="prettyprint">key</code> is existed in parameter server.</em></p>

<h3 id="bool-paracel_remove(const-std::string-&amp;-key);">bool paracel_remove(const std::string &amp; key);</h3>

<p><em>Remove key-value pair in parameter server.</em></p>

<h3 id="void-paracel_sync();">void paracel_sync();</h3>

<p><em>Block until all workers have reached this line of code.</em></p>

<h3 id="void-set_decomp_info(const-std::string-&amp;-pattern);">void set_decomp_info(const std::string &amp; pattern);</h3>

<p><em>Set decomposition infomation by <code class="prettyprint">pattern</code>(fmap, smap, fsmap, fvec&hellip;).</em></p>

<h3 id="void-get_decomp_info(int-&amp;-x,-int-&amp;-y);">void get_decomp_info(int &amp; x, int &amp; y);</h3>

<p><em>Get decomposition infomation from <code class="prettyprint">x</code> and <code class="prettyprint">y</code>. <code class="prettyprint">x</code> refers to the number of partition in the horizontal direction while <code class="prettyprint">y</code> refers to the number of partition in the vertical direction.</em></p>

<h3 id="size_t-get_worker_id();">size_t get_worker_id();</h3>

<p><em>Get the worker id.</em></p>

<h3 id="size_t-get_worker_size();">size_t get_worker_size();</h3>

<p><em>Get the size of workers.</em></p>

<h3 id="size_t-get_server_size();">size_t get_server_size();</h3>

<p><em>Get the size of servers.</em></p>

<h3 id="paracel::comm-get_comm();">paracel::Comm get_comm();</h3>

<p><em>Get workers&rsquo; communication channel, you can use the returned channel to do low-level communication between workers. See more interfaces in the <a href="#communicator">communicator</a> section.</em></p>

<aside class="success">
Remember
<p>
<p> - If key do not exist, <b>paracel_update</b>/<b>paracel_bupdate</b> equals to <b>paracel_write</b>.
<p> - If you need more than one registry functions, we suggest to use interfaces that containing the arguments <b>file_name</b> and <b>func_name</b> instead of register ones.
<p> - <b>Paracel_write</b> is idempotent while <b>paracel_bupdate</b> is not.
<p> - In most cases, we suggest to choose <b>paracel_bupdate</b> to ensure the correctness.
</aside>

<h2 id="dump">Dump</h2>
<pre><code class="highlight cpp">
<span class="cp">#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;google/gflags.h&gt;
#include "ps.hpp"
#include "utils.hpp"
</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">foo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">paracel</span><span class="o">::</span><span class="n">pralg</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">foo</span><span class="p">(</span><span class="n">paracel</span><span class="o">::</span><span class="n">Comm</span> <span class="n">comm</span><span class="p">,</span> <span class="n">string</span> <span class="n">hosts_dct_str</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">paracel</span><span class="o">::</span><span class="n">paralg</span><span class="p">(</span><span class="n">hosts_dct_str</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="s">"/nfs/tmp/paracel_output/"</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">save</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">data1</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">};</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">data2</span><span class="p">;</span>
    <span class="n">data2</span><span class="p">[</span><span class="s">"a"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">data2</span><span class="p">[</span><span class="s">"b"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">data3</span><span class="p">;</span>
    <span class="n">data3</span><span class="p">[</span><span class="s">"c"</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.</span><span class="p">;</span> <span class="n">data3</span><span class="p">[</span><span class="s">"d"</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">data4</span><span class="p">;</span>
    <span class="n">data4</span><span class="p">[</span><span class="s">"e"</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.23</span><span class="p">,</span> <span class="mf">2.34</span><span class="p">,</span> <span class="mf">3.45</span><span class="p">};</span>
    <span class="n">data4</span><span class="p">[</span><span class="s">"f"</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">5.43</span><span class="p">,</span> <span class="mf">4.32</span><span class="p">,</span> <span class="mf">3.21</span><span class="p">};</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span>
                <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">data5</span><span class="p">;</span>
    <span class="n">data5</span><span class="p">[</span><span class="s">"g"</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">make_pair</span><span class="p">(</span><span class="s">"i"</span><span class="p">,</span> <span class="mf">3.1415926</span><span class="p">),</span>
                <span class="n">make_pair</span><span class="p">(</span><span class="s">"j"</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">)</span> <span class="p">};</span>
    <span class="n">data5</span><span class="p">[</span><span class="s">"h"</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">make_pair</span><span class="p">(</span><span class="s">"x"</span><span class="p">,</span> <span class="mf">3.1415</span><span class="p">),</span>
                <span class="n">make_pair</span><span class="p">(</span><span class="s">"y"</span><span class="p">,</span> <span class="mf">3.141</span><span class="p">)</span> <span class="p">};</span>
    <span class="n">paracel_dump_vector</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="s">"data1_"</span><span class="p">);</span>
    <span class="n">paracel_dump_dict</span><span class="p">(</span><span class="n">data2</span><span class="p">,</span> <span class="s">"data2_"</span><span class="p">);</span>
    <span class="n">paracel_dump_dict</span><span class="p">(</span><span class="n">data3</span><span class="p">,</span> <span class="s">"data3_"</span><span class="p">);</span>
    <span class="n">paracel_dump_dict</span><span class="p">(</span><span class="n">data4</span><span class="p">,</span> <span class="s">"data4_"</span><span class="p">);</span>
    <span class="n">paracel_dump_dict</span><span class="p">(</span><span class="n">data5</span><span class="p">,</span> <span class="s">"data4_"</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
  <span class="p">}</span>

<span class="p">};</span>

<span class="n">DEFINE_string</span><span class="p">(</span><span class="n">server_info</span><span class="p">,</span>
    <span class="s">"host1:7777PARACELhost2:8888"</span><span class="p">,</span>
    <span class="s">"hosts name string of paracel-servers.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">paracel</span><span class="o">::</span><span class="n">main_env</span> <span class="n">comm_main_env</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
  <span class="n">paracel</span><span class="o">::</span><span class="n">Comm</span> <span class="n">comm</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
  <span class="n">google</span><span class="o">::</span><span class="n">SetUsageMessage</span><span class="p">(</span><span class="s">"[options]</span><span class="se">\n\t</span><span class="s">--server_info</span><span class="se">\n\t</span><span class="s">--cfg_file</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">google</span><span class="o">::</span><span class="n">ParseCommandLineFlags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
  <span class="n">foo</span> <span class="n">solver</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">FLAGS_server_info</span><span class="p">);</span>
  <span class="n">solver</span><span class="p">.</span><span class="n">save</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>

<p>Paracel implements several dumping interfaces below. They are all defined in the <code class="prettyprint">paralg</code> baseclass. Since there are very limited data types supported, you must write your own dumper in most cases.</p>

<h3 id="template&lt;class-v&gt;void-paracel_dump_vector(const-std::vector&lt;v&gt;-&amp;-data,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-string-&amp;-file_prefix-=-&quot;result_&quot;,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-string-&amp;-sep-=-&quot;,&quot;,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool-append_flag-=-false,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool-merge-=-false);">template&lt;class V&gt;<br>void paracel_dump_vector(const std::vector&lt;V&gt; &amp; data,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const string &amp; file_prefix = &ldquo;result_&rdquo;,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const string &amp; sep = &ldquo;,&rdquo;,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool append_flag = false,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool merge = false);</h3>

<h3 id="void-paracel_dump_dict(const-unordered_map&lt;string,-int&gt;&amp;-data,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-string-&amp;-file_prefix-=-&quot;result_&quot;,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool-append_flag-=-false,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool-merge-=-false);">void paracel_dump_dict(const unordered_map&lt;string, int&gt;&amp; data,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const string &amp; file_prefix = &ldquo;result_&rdquo;,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool append_flag = false,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool merge = false);</h3>

<h3 id="void-paracel_dump_dict(const-unordered_map&lt;string,-double&gt;&amp;-data,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-string-&amp;-file_prefix-=-&quot;result_&quot;,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool-append_flag-=-false,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool-merge-=-false);">void paracel_dump_dict(const unordered_map&lt;string, double&gt;&amp; data,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const string &amp; file_prefix = &ldquo;result_&rdquo;,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool append_flag = false,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool merge = false);</h3>

<h3 id="template&lt;class-t,-class-p&gt;void-paracel_dump_dict(&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-unordered_map&lt;t,-vector&lt;p&gt;-&gt;-&amp;-data,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const-string-&amp;-file_prefix-=-&quot;result_&quot;,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool-append_flag-=-false,&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool-merge-=-false);">template&lt;class T, class P&gt;<br>void paracel_dump_dict(<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const unordered_map&lt;T, vector&lt;P&gt; &gt; &amp; data,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;const string &amp; file_prefix = &ldquo;result_&rdquo;,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool append_flag = false,<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;bool merge = false);</h3>

<h3 id="void-paracel_dump_dict(&ensp;&ensp;const-unordered_map&lt;string,-vector&lt;pair&lt;string,-double&gt;-&gt;-&gt;-&amp;-data,&ensp;&ensp;const-string-&amp;-file_prefix-=-&quot;result_&quot;,&ensp;&ensp;bool-append_flag-=-false,&ensp;&ensp;bool-merge-=-false);">void paracel_dump_dict(<br>&ensp;&ensp;const unordered_map&lt;string, vector&lt;pair&lt;string, double&gt; &gt; &gt; &amp; data,<br>&ensp;&ensp;const string &amp; file_prefix = &ldquo;result_&rdquo;,<br>&ensp;&ensp;bool append_flag = false,<br>&ensp;&ensp;bool merge = false);</h3>

<aside class="notice">
<b>File_prefix</b> refer to the prefix of the output file name. For example, if you use two workers, Paracel will dump results into the output folder with file result_0 and result_1.
</aside>

<h2 id="asynchronous-controlling">Asynchronous Controlling</h2>
<pre><code class="highlight cpp"><span class="k">class</span> <span class="nc">logistic</span><span class="n">_regression</span><span class="o">:</span> <span class="k">public</span> <span class="n">paracel</span><span class="o">::</span><span class="n">paralg</span> <span class="p">{</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">logistic_regression</span><span class="p">(</span><span class="n">paracel</span><span class="o">::</span><span class="n">Comm</span> <span class="n">comm</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">hosts_dct_str</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_output</span><span class="p">,</span>
            <span class="kt">int</span> <span class="n">_rounds</span><span class="p">,</span>
            <span class="kt">int</span> <span class="n">_limit_s</span><span class="p">,</span>
            <span class="n">bool</span> <span class="n">_ssp_switch</span><span class="p">)</span> <span class="o">:</span>
        <span class="n">paracel</span><span class="o">::</span><span class="n">paralg</span><span class="p">(</span><span class="n">hosts_dct_str</span><span class="p">,</span>
                        <span class="n">comm</span><span class="p">,</span>
                        <span class="n">_output</span><span class="p">,</span>
                        <span class="n">_rounds</span><span class="p">,</span>
                        <span class="n">_limit_s</span><span class="p">,</span>
                        <span class="n">_ssp_switch</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">training</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">paracel</span><span class="o">::</span><span class="n">random_double_list</span><span class="p">(</span><span class="n">data_dim</span><span class="p">);</span>
    <span class="n">paracel_write</span><span class="p">(</span><span class="s">"theta"</span><span class="p">,</span> <span class="n">theta</span><span class="p">);</span> <span class="c1">// init push
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iter</span> <span class="o">&lt;</span> <span class="n">rounds</span><span class="p">;</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data_dim</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">random_shuffle</span><span class="p">(</span><span class="n">idx</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">idx</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

      <span class="c1">// pull theta
</span>      <span class="n">theta</span> <span class="o">=</span> <span class="n">paracel_read</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="s">"theta"</span><span class="p">);</span>

      <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">sample_id</span> <span class="o">:</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data_dim</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">coff1</span> <span class="o">*</span>
            <span class="n">samples</span><span class="p">[</span><span class="n">sample_id</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">coff2</span> <span class="o">*</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="c1">// traverse
</span>
      <span class="c1">// update theta with delta
</span>      <span class="n">paracel_bupdate</span><span class="p">(</span><span class="s">"theta"</span><span class="p">,</span>
                    <span class="n">delta</span><span class="p">,</span>
                    <span class="s">"update.so"</span><span class="p">,</span>
                    <span class="s">"lg_theta_update"</span><span class="p">);</span>

      <span class="c1">// commit to server at the end of each iteration
</span>      <span class="n">iter_commit</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// last pull
</span>    <span class="n">theta</span> <span class="o">=</span> <span class="n">paracel_read</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="s">"theta"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">solve</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// init training data
</span>    <span class="k">auto</span> <span class="n">parser</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* ... */</span>
    <span class="p">};</span>
    <span class="k">auto</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">paracel_load</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="n">parser</span><span class="p">(</span><span class="n">lines</span><span class="p">);</span>
    <span class="n">paracel_sync</span><span class="p">();</span>

    <span class="c1">// set total iterations of your training process
</span>    <span class="n">set_total_iters</span><span class="p">(</span><span class="n">rounds</span><span class="p">);</span>

    <span class="c1">// training
</span>    <span class="n">training</span><span class="p">();</span>
  <span class="p">}</span>

<span class="p">};</span> <span class="c1">// class logistic regression
</span></code></pre>

<p>Many machine learning problems can be converted to an iterative task, the traditional way to do that is using <a href="http://en.wikipedia.org/wiki/Bulk_synchronous_parallel">BSP</a> model which means we must synchronize at the end of every iterator. This leads to the <a href="http://stackoverflow.com/questions/16836770/last-reducer-tasks-are-taking-long-time-to-finish">last reducer problem</a>. The straggled worker came out because of some hareware related reasons such as network congestion, CPU interrupts, produrement of machines in different years and some software related reasons such as garbage collection, virtualization and so on.   </p>

<p>There are two ways to solve this problem: firstly, we have to write some tricky code to make load imbalance so we could make a fast worker training more data. Secondly, we can do some asynchronous controlling to relax the synchronization condition.    </p>

<p>Paracel use the second solution, we relax the synchronization condition with an assumption that the fastest worker can lead no more than a bounded parameter with the slowest worker which is a trade-off between convergence of every iteration and total time of convergence. We have some similar ideas with the <a href="https://www.usenix.org/conference/hotos13/session/cipar">SSP</a> data structure. The attractive point is that you only have to add few lines of code to transform a BSP process to an asynchronous process. The asynchronous iterfaces are listed below and we will show you a very simple example in the right.</p>

<h3 id="void-iter_commit();">void iter_commit();</h3>

<p><em>Commit to parameter servers at the end of each iteration.</em></p>

<h3 id="void-set_total_iters(int-n);">void set_total_iters(int n);</h3>

<p><em>Set total number of iterations. You have to use this function to tell Paracel the total number of iterations beforehand.</em></p>

<h3 id="template&lt;class-v&gt;v-get_cache(const-std::string-&amp;-key);">template&lt;class V&gt;<br>V get_cache(const std::string &amp; key);</h3>

<p><em>Get cached value of specified <code class="prettyprint">key</code> locally.</em></p>

<h3 id="bool-is_cached(const-std::string-&amp;-key);">bool is_cached(const std::string &amp; key);</h3>

<p><em>Check whether the value of specified <code class="prettyprint">key</code> is cached locally.</em></p>

<p>Except above functions, there are two important parameters you have to use: <code class="prettyprint">ssp_switch</code> and <code class="prettyprint">limit_s</code>. <code class="prettyprint">ssp_switch</code> is the switch and <code class="prettyprint">limit_s</code> is the bound parameter, all of them must be set in the <a href="#initialize">constructor</a> of paralg baseclass.     </p>

<p>The logistic regression example on the right describe the usage in detail. As you can see, you only need to add four lines of code in original version.</p>

<h1 id="registry-function">Registry Function</h1>

<p>A registry function is a user-define function that interacts with Paracel framework.</p>

<p>You must follow the predefined interface below and can do anything you want inside a registry function. Then you need to register your function into Paracel. After compiling and installing your code, you can specify the registry function with the shared library file name and function name you defined.</p>

<h3 id="//-substitute-name-with-your-update-function-nametemplate-&lt;class-t&gt;t-name(t-&amp;-a,-t-&amp;-b);">// substitute <code class="prettyprint">name</code> with your update function name<br>template &lt;class T&gt;<br>T name(T &amp; a, T &amp; b);</h3>

<h3 id="//-substitute-name-with-your-filter-function-namebool-name(const-std::string-&amp;-key);">// substitute <code class="prettyprint">name</code> with your filter function name<br>bool name(const std::string &amp; key);</h3>

<h2 id="update-function">Update Function</h2>
<pre><code class="highlight cpp"><span class="cm">/* update.cpp */</span>
<span class="cp">#include "proxy.hpp"
#include "paracel_types.hpp"
</span>
<span class="c1">// wrap c++ function here
</span><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="n">paracel</span><span class="o">::</span><span class="n">update_result</span> <span class="n">sum_updater</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// define your update function here
// return type must be the same with parameter a and parameter b
</span><span class="kt">double</span> <span class="n">foo</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// register into Paracel framework
</span><span class="n">paracel</span><span class="o">::</span><span class="n">update_result</span> <span class="n">sum_updater</span> <span class="o">=</span> <span class="n">paracel</span><span class="o">::</span><span class="n">update_proxy</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</code></pre>

<p>A update registry function can be used together with <code class="prettyprint">paracel_update</code>, <code class="prettyprint">paracel_bupdate</code> and so on. It is something like the reduce function in map-reduce paradigm which will be dynamicly executed in the server side. For example, in the code area we define a simple sum updater in file <code class="prettyprint">update.cpp</code> and in the corresponding <code class="prettyprint">CMakeLists.txt</code> file we add:</p>

<h3 id="add_library(update-shared-update.cpp)">add_library(update SHARED update.cpp)</h3>

<h3 id="target_link_libraries(update-${cmake_dl_libs})">target_link_libraries(update ${CMAKE_DL_LIBS})</h3>

<h3 id="install(targets-update-library-destination-lib)">install(TARGETS update LIBRARY DESTINATION lib)</h3>

<p><p>After compiling and installing the code, you can specify your update function with the shared library file name:<code class="prettyprint">xxx/lib/libupdate.so</code> and the function name inside: <code class="prettyprint">sum_updater</code>(here xxx refer to your path for Paracel installation).</p>

<h2 id="filter-function">Filter Function</h2>
<pre><code class="highlight cpp"><span class="cm">/* filter.cpp */</span>
<span class="cp">#include "proxy.hpp"
#include "paracel_types.hpp"
</span>
<span class="c1">// wrap c++ function here
</span><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="n">paracel</span><span class="o">::</span><span class="n">filter_with_key_result</span> <span class="n">key_filter</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// define your filter function here
// return bool, parameter must be std::string
</span><span class="n">bool</span> <span class="n">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">paracel</span><span class="o">::</span><span class="n">startswith</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">"doc"</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// register into Paracel framework
</span><span class="n">paracel</span><span class="o">::</span><span class="n">filter_with_key_result</span> <span class="n">key_filter</span> <span class="o">=</span> <span class="n">paracel</span><span class="o">::</span><span class="n">filter_with_key_proxy</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
</code></pre>

<p>A filter registry function can be used together with <code class="prettyprint">paracel_read_special</code> and <code class="prettyprint">paracel_read_special_handle</code> which will read special key-value pairs from all paramter servers. Workers can only pull key-value pairs that the filter function return true.</p>

<h3 id="add_library(filter-shared-filter.cpp)">add_library(filter SHARED filter.cpp)</h3>

<h3 id="target_link_libraries(filter-${cmake_dl_libs})">target_link_libraries(filter ${CMAKE_DL_LIBS})</h3>

<h3 id="install(targets-filter-library-destination-lib)">install(TARGETS filter LIBRARY DESTINATION lib)</h3>

<p><p>Similarly, you must add compile information in the corresponding <code class="prettyprint">CMakeLists.txt</code> and after compiling and installing the code, you can specify your filter function with the shared library file name:<code class="prettyprint">xxx/lib/libfilter.so</code> and the function name inside: <code class="prettyprint">key_filter</code>(here xxx refer to your path for Paracel installation).</p>

<p>In the right example, say we have <code class="prettyprint">{&quot;doc_key1&quot; : 1.23, &quot;key2&quot; : &quot;world&quot;}</code> stored in parameter server, and invoking<p><code class="prettyprint">paracel_read_special(&quot;xxx/lib/libfilter.so&quot;, &quot;key_filter&quot;)</code><p>will only return <code class="prettyprint">{&quot;doc_key1&quot; : 1.23}</code>.</p>

<h1 id="utility">Utility</h1>

<p>Paracel provide some scattered utility for common use functionality and we are planning to encapsulate them with high-level abstraction in next release.</p>

<h2 id="communicator">Communicator</h2>
<pre><code class="highlight cpp">
<span class="c1">// worker number = 2
</span><span class="cp">#include &lt;vector&gt;
#include &lt;tuple&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;unordered_map&gt;
#include &lt;mpi.h&gt;
#include "utils/comm.hpp"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">paracel</span><span class="o">::</span><span class="n">main_env</span> <span class="n">comm_main_env</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
  <span class="n">paracel</span><span class="o">::</span><span class="n">Comm</span> <span class="n">comm</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">rk</span> <span class="o">=</span> <span class="n">comm</span><span class="p">.</span><span class="n">get_rank</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">comm</span><span class="p">.</span><span class="n">get_size</span><span class="p">();</span>
  <span class="n">comm</span><span class="p">.</span><span class="n">get_rank</span><span class="p">();</span>

  <span class="p">{</span> <span class="c1">// builtin send + recv
</span>    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
      <span class="n">comm</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
      <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">comm</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// isend + recv
</span>    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
      <span class="n">paracel</span><span class="o">::</span><span class="n">vrequest</span> <span class="n">req</span><span class="p">;</span>
      <span class="n">req</span> <span class="o">=</span> <span class="n">comm</span><span class="p">.</span><span class="n">isend</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
      <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">comm</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// container send + recv
</span>    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">aa</span> <span class="p">{</span><span class="mi">77</span><span class="p">,</span> <span class="mi">88</span><span class="p">};</span>
      <span class="n">comm</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bb</span><span class="p">;</span>
      <span class="n">comm</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// container isend + recv
</span>    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">aa</span> <span class="p">{</span><span class="mi">77</span><span class="p">,</span> <span class="mi">88</span><span class="p">};</span>
      <span class="n">paracel</span><span class="o">::</span><span class="n">vrequest</span> <span class="n">req</span><span class="p">;</span>
      <span class="n">req</span> <span class="o">=</span> <span class="n">comm</span><span class="p">.</span><span class="n">isend</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bb</span><span class="p">;</span>
      <span class="n">comm</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// paracel triple send + recv
</span>    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">aa</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">aa</span><span class="p">)</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">aa</span><span class="p">)</span> <span class="o">=</span> <span class="s">"def"</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">aa</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
      <span class="n">paracel</span><span class="o">::</span><span class="n">vrequest</span> <span class="n">req</span><span class="p">;</span>
      <span class="n">req</span> <span class="o">=</span> <span class="n">comm</span><span class="p">.</span><span class="n">isend</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">bb</span><span class="p">;</span>
      <span class="n">comm</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// paracel list of triple send + recv
</span>    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">aa</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">tmp1</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"def"</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.15</span><span class="p">;</span> <span class="n">aa</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp1</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">tmp2</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)</span> <span class="o">=</span> <span class="s">"cba"</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)</span> <span class="o">=</span> <span class="s">"fed"</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)</span> <span class="o">=</span> <span class="mf">5.16</span><span class="p">;</span> <span class="n">aa</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp2</span><span class="p">);</span>
      <span class="n">paracel</span><span class="o">::</span><span class="n">vrequest</span> <span class="n">req</span><span class="p">;</span>
      <span class="n">req</span> <span class="o">=</span> <span class="n">comm</span><span class="p">.</span><span class="n">isend</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">bb</span><span class="p">;</span>
      <span class="n">comm</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// another paracel list of triple send + recv
</span>    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">aa</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">tmp1</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"def"</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.15</span><span class="p">;</span> <span class="n">aa</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp1</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">tmp2</span><span class="p">;</span>
      <span class="n">aa</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp2</span><span class="p">);</span>
      <span class="n">paracel</span><span class="o">::</span><span class="n">vrequest</span> <span class="n">req</span><span class="p">;</span>
      <span class="n">req</span> <span class="o">=</span> <span class="n">comm</span><span class="p">.</span><span class="n">isend</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">bb</span><span class="p">;</span>
      <span class="n">comm</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// builtin sendrecv
</span>    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">;</span>
    <span class="n">right</span> <span class="o">=</span> <span class="p">(</span><span class="n">rk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">sz</span><span class="p">;</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">rk</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">left</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">comm</span><span class="p">.</span><span class="n">sendrecv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="mi">2014</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// container sendrecv
</span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">aaa</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bbb</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">;</span>
    <span class="n">right</span> <span class="o">=</span> <span class="p">(</span><span class="n">rk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">sz</span><span class="p">;</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">rk</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">left</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">comm</span><span class="p">.</span><span class="n">sendrecv</span><span class="p">(</span><span class="n">aaa</span><span class="p">,</span> <span class="n">bbb</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="mi">2014</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// paracel triple sendrecv
</span>    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">aa</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">bb</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">aa</span><span class="p">)</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">aa</span><span class="p">)</span> <span class="o">=</span> <span class="s">"def"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">aa</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">;</span>
    <span class="n">right</span> <span class="o">=</span> <span class="p">(</span><span class="n">rk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">sz</span><span class="p">;</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">rk</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">left</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">comm</span><span class="p">.</span><span class="n">sendrecv</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="mi">2014</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// paracel list of triple sendrecv
</span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">bb</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">aa</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">tmp1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"def"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.15</span><span class="p">;</span> <span class="n">aa</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp1</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">tmp2</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)</span> <span class="o">=</span> <span class="s">"cba"</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)</span> <span class="o">=</span> <span class="s">"fed"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)</span> <span class="o">=</span> <span class="mf">5.16</span><span class="p">;</span> <span class="n">aa</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp2</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">;</span>
    <span class="n">right</span> <span class="o">=</span> <span class="p">(</span><span class="n">rk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">sz</span><span class="p">;</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">rk</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">left</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">comm</span><span class="p">.</span><span class="n">sendrecv</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="mi">2014</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// another paracel list of triple sendrecv
</span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">bb</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">aa</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">tmp1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"def"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.15</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">tmp2</span><span class="p">;</span>
    <span class="n">aa</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp2</span><span class="p">);</span> <span class="n">aa</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp1</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">;</span>
    <span class="n">right</span> <span class="o">=</span> <span class="p">(</span><span class="n">rk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">sz</span><span class="p">;</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">rk</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">left</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">comm</span><span class="p">.</span><span class="n">sendrecv</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="mi">2014</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// debug for list of triple sendrecv
</span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">aa</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">bb</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">aaa</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">tmp1</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"a"</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"b"</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="n">aaa</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp1</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"a"</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"c"</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="n">aaa</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp1</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"a"</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"d"</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="n">aaa</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp1</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"b"</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"a"</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="n">aaa</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp1</span><span class="p">);</span>
      <span class="n">aa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">aaa</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">aaa</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">tmp1</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"e"</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"a"</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="n">aaa</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp1</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"e"</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="s">"d"</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="n">aaa</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp1</span><span class="p">);</span>
      <span class="n">aa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">aaa</span><span class="p">;</span>

      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">aaaa</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">tmp2</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)</span> <span class="o">=</span> <span class="s">"b"</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)</span> <span class="o">=</span> <span class="s">"d"</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="n">aaaa</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp2</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)</span> <span class="o">=</span> <span class="s">"d"</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)</span> <span class="o">=</span> <span class="s">"c"</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="n">aaaa</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp2</span><span class="p">);</span>
      <span class="n">aa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">aaaa</span><span class="p">;</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">comm</span><span class="p">.</span><span class="n">sendrecv</span><span class="p">(</span><span class="n">aa</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">bb</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">2014</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// builtin bcast
</span>    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="n">comm</span><span class="p">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// container bcast
</span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">aa</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">aa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">aa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">comm</span><span class="p">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// builtin alltoall
</span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">comm</span><span class="p">.</span><span class="n">alltoall</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// container alltoall
</span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tmp1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tmp2</span><span class="p">{</span><span class="mi">3</span><span class="p">};</span>
      <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp1</span><span class="p">;</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tmp1</span><span class="p">{</span><span class="mi">2</span><span class="p">};</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tmp2</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">};</span>
      <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp1</span><span class="p">;</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">comm</span><span class="p">.</span><span class="n">alltoall</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// builtin allreduce
</span>    <span class="kt">int</span> <span class="n">aaa</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">aaa</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="n">aaa</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">comm</span><span class="p">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">aaa</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// container allreduce
</span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">aaa</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">aaa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">aaa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">aaa</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">aaa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">aaa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">aaa</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">comm</span><span class="p">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">aaa</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// bcastring
</span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span> <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">28</span><span class="p">);</span> <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
      <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">28</span><span class="p">);</span> <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="p">){</span>
      <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="n">stf</span> <span class="o">:</span> <span class="n">tmp</span><span class="p">)</span>
        <span class="n">result</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">stf</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="n">comm</span><span class="p">.</span><span class="n">bcastring</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">{</span> <span class="c1">// dict_type&lt;size_t, int&gt; isend
</span>    <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">aa</span><span class="p">;</span>
      <span class="n">aa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">aa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
      <span class="n">paracel</span><span class="o">::</span><span class="n">vrequest</span> <span class="n">req</span><span class="p">;</span>
      <span class="n">req</span> <span class="o">=</span> <span class="n">comm</span><span class="p">.</span><span class="n">isend</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rk</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">bb</span><span class="p">;</span>
      <span class="n">comm</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2014</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>

<p>Communicator stands for the collection of workers. Paracel&rsquo;s communicator has the same meaning as <a href="http://static.msi.umn.edu/tutorial/scicomp/general/MPI/communicator.html">MPI communicator</a>. We provide a C++ interface, but we are still suggesting you to do communication between parameter servers unless very special cases. Do not use low-level interfaces given in this section unless you know what you&rsquo;re doing.</p>

<h3 id="class-comm-{&nbsp;public:&nbsp;&nbsp;comm(mpi_comm-comm-=-mpi_comm_world);">class Comm {<br><br>&nbsp;public:<br>&nbsp;&nbsp;Comm(MPI_Comm comm = MPI_COMM_WORLD);</h3>

<p><em>&nbsp;&nbsp;Constructor</em></p>

<h3 id="&nbsp;&nbsp;inline-size_t-get_size()-const;">&nbsp;&nbsp;inline size_t get_size() const;</h3>

<p><em>&nbsp;&nbsp;Get the number of workers.</em></p>

<h3 id="&nbsp;&nbsp;inline-size_t-get_rank()-const;">&nbsp;&nbsp;inline size_t get_rank() const;</h3>

<p><em>&nbsp;&nbsp;Get the id of worker.</em></p>

<h3 id="&nbsp;&nbsp;inline-mpi_comm-get_comm()-const;">&nbsp;&nbsp;inline MPI_Comm get_comm() const;</h3>

<p><em>&nbsp;&nbsp;Get communicator field.</em></p>

<h3 id="&nbsp;&nbsp;inline-void-synchronize();">&nbsp;&nbsp;inline void synchronize();</h3>

<p><em>&nbsp;&nbsp;Block until all workers in this communicator have reached this routine.</em></p>

<h3 id="&nbsp;&nbsp;int-get_source(mpi_status-&amp;-stat);">&nbsp;&nbsp;int get_source(MPI_Status &amp; stat);</h3>

<p><em>&nbsp;&nbsp;Get source id.</em></p>

<h3 id="&nbsp;&nbsp;comm-split(int-color);">&nbsp;&nbsp;Comm split(int color);</h3>

<p><em>&nbsp;&nbsp;Split the communicator into sub-communicators using <code class="prettyprint">color</code>.</em></p>

<h3 id="&nbsp;&nbsp;void-wait(mpi_request-&amp;-req);">&nbsp;&nbsp;void wait(MPI_Request &amp; req);</h3>

<p><em>&nbsp;&nbsp;Wait for an MPI request to complete.</em></p>

<h3 id="&nbsp;&nbsp;void-wait(vrequest-&amp;-v_req);">&nbsp;&nbsp;void wait(vrequest &amp; v_req);</h3>

<p><em>&nbsp;&nbsp;Wait for an MPI request to complete</em></p>

<h3 id="&nbsp;&nbsp;template&lt;class-t&gt;&nbsp;&nbsp;void-send(const-t-&amp;-data,-int-dest,-int-tag);">&nbsp;&nbsp;template&lt;class T&gt;<br>&nbsp;&nbsp;void send(const T &amp; data, int dest, int tag);</h3>

<p><em>&nbsp;&nbsp;Block send messages.</em></p>

<h3 id="&nbsp;&nbsp;template&lt;class-t&gt;&nbsp;&nbsp;void-isend(const-t-&amp;-data,-int-dest,-int-tag);">&nbsp;&nbsp;template&lt;class T&gt;<br>&nbsp;&nbsp;void isend(const T &amp; data, int dest, int tag);</h3>

<p><em>&nbsp;&nbsp;Non-blocking send messages.</em></p>

<h3 id="&nbsp;&nbsp;template&lt;class-t&gt;&nbsp;&nbsp;void-recv(t-&amp;-data,-int-src,-int-tag);">&nbsp;&nbsp;template&lt;class T&gt;<br>&nbsp;&nbsp;void recv(T &amp; data, int src, int tag);</h3>

<p><em>&nbsp;&nbsp;Receive messages.</em></p>

<h3 id="&nbsp;&nbsp;template&lt;class-t&gt;&nbsp;&nbsp;void-sendrecv(const-t-&amp;-sdata,-t-&amp;-rdata,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int-sto,-int-stag,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int-rfrom,-int-rtag);">&nbsp;&nbsp;template&lt;class T&gt;<br>&nbsp;&nbsp;void sendrecv(const T &amp; sdata, T &amp; rdata,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int sto, int stag,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int rfrom, int rtag);</h3>

<p><em>&nbsp;&nbsp;Receive <code class="prettyprint">rdata</code> from <code class="prettyprint">rfrom</code>, and send <code class="prettyprint">sdata</code> to <code class="prettyprint">sto</code>.</em></p>

<h3 id="&nbsp;&nbsp;template&lt;class-t&gt;&nbsp;&nbsp;void-bcast(t-&amp;-data,-int-master);">&nbsp;&nbsp;template&lt;class T&gt;<br>&nbsp;&nbsp;void bcast(T &amp; data, int master);</h3>

<p><em>&nbsp;&nbsp;Broadcast master&rsquo;s <code class="prettyprint">data</code>.</em></p>

<h3 id="&nbsp;&nbsp;template&lt;class-t,-class-f&gt;&nbsp;&nbsp;void-bcastring(const-t-&amp;-data,-f-&amp;-func);">&nbsp;&nbsp;template&lt;class T, class F&gt;<br>&nbsp;&nbsp;void bcastring(const T &amp; data, F &amp; func);</h3>

<p><em>&nbsp;&nbsp;Broadcast every worker&rsquo;s <code class="prettyprint">data</code> and handle with functor <code class="prettyprint">func</code>.</em></p>

<h3 id="&nbsp;&nbsp;template&lt;class-t&gt;&nbsp;&nbsp;void-alltoall(const-t-&amp;-sbuf,-t-&amp;-rbuf);">&nbsp;&nbsp;template&lt;class T&gt;<br>&nbsp;&nbsp;void alltoall(const T &amp; sbuf, T &amp; rbuf);</h3>

<p><em>&nbsp;&nbsp;Send data from all to all workers.</em></p>

<h3 id="&nbsp;&nbsp;template&lt;class-t,-class-f&gt;&nbsp;&nbsp;void-alltoallring(const-t-&amp;-sbuf,-t-&amp;-rbuf,-f-&amp;-func);">&nbsp;&nbsp;template&lt;class T, class F&gt;<br>&nbsp;&nbsp;void alltoallring(const T &amp; sbuf, T &amp; rbuf, F &amp; func);</h3>

<p><em>&nbsp;&nbsp;Send data from all to all workers and handle with functor <code class="prettyprint">func</code>.</em></p>

<h3 id="&nbsp;&nbsp;template&lt;class-t&gt;&nbsp;&nbsp;void-allreduce(t-&amp;-data);">&nbsp;&nbsp;template&lt;class T&gt;<br>&nbsp;&nbsp;void allreduce(T &amp; data);</h3>

<p><em>&nbsp;&nbsp;Combine values from all workers and distributes the result back to all workers. Only supported summation in current version.</em></p>

<h3 id="&nbsp;&nbsp;template&lt;class-t,-class-f&gt;&nbsp;&nbsp;t-treereduce(t-&amp;-data,-f-&amp;-func,-int-rank-=-0);">&nbsp;&nbsp;template&lt;class T, class F&gt;<br>&nbsp;&nbsp;T treereduce(T &amp; data, F &amp; func, int rank = 0);</h3>

<p><em>&nbsp;&nbsp;Treereduce using functor <code class="prettyprint">func</code>.</em></p>

<h3 id="};-//-class-comm">}; // class Comm</h3>

<p><br><br>
<aside class = "notice">
Actually, the return type of above iterfaces are very flexiable because there are so many override versions. Here we just all use <b>void</b> for convenience while it does not affect the use.
</aside></p>

<h2 id="json_parser">Json_parser</h2>
<pre><code class="highlight cpp"><span class="cp">#include "utils.hpp"
</span>
<span class="kt">void</span> <span class="nf">json_parser_usage</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">paracel</span><span class="o">::</span><span class="n">json_parser</span> <span class="n">pt</span><span class="p">(</span><span class="s">"demo.json"</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">pt</span><span class="p">.</span><span class="n">parse</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"wu"</span><span class="p">);</span> <span class="c1">// "hong"
</span>  <span class="kt">int</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">pt</span><span class="p">.</span><span class="n">parse</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"hong"</span><span class="p">);</span> <span class="c1">// 7
</span>  <span class="n">bool</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">pt</span><span class="p">.</span><span class="n">parse</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"changsheng"</span><span class="p">);</span> <span class="c1">// true
</span>  <span class="kt">double</span> <span class="n">r4</span> <span class="o">=</span> <span class="n">pt</span><span class="p">.</span><span class="n">parse</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"jiang"</span><span class="p">);</span> <span class="c1">// 3.141592653
</span>
  <span class="c1">// {"hong", "xun", "zhang"}
</span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">r5</span> <span class="o">=</span> <span class="n">pt</span><span class="p">.</span><span class="n">parse_v</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"wul"</span><span class="p">);</span>

  <span class="c1">// {1, 2, 3, 4, 5, 6, 7}
</span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r6</span> <span class="o">=</span> <span class="n">pt</span><span class="p">.</span><span class="n">parse_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"hongl"</span><span class="p">);</span>

  <span class="c1">// {true, false, false, true, true}
</span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span> <span class="n">r7</span> <span class="o">=</span> <span class="n">pt</span><span class="p">.</span><span class="n">parse_v</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"changshengl"</span><span class="p">);</span>

  <span class="c1">// {1.23, 2.34, 3.45, 4.56, 5.67, 6.78, 7.89}
</span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">r8</span> <span class="o">=</span> <span class="n">pt</span><span class="p">.</span><span class="n">parse_v</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"jiangl"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<pre><code class="highlight json"><span class="p">{</span><span class="w">
  </span><span class="s2">"wu"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"hong"</span><span class="p">,</span><span class="w">
  </span><span class="s2">"hong"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w">
  </span><span class="s2">"changsheng"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
  </span><span class="s2">"jiang"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mf">3.141592653</span><span class="p">,</span><span class="w">
  </span><span class="s2">"wul"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"hong"</span><span class="p">,</span><span class="w"> </span><span class="s2">"xun"</span><span class="p">,</span><span class="w"> </span><span class="s2">"zhang"</span><span class="p">],</span><span class="w">
  </span><span class="s2">"hongl"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">],</span><span class="w">
  </span><span class="s2">"changshengl"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">],</span><span class="w">
  </span><span class="s2">"jiangl"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mf">1.23</span><span class="p">,</span><span class="w"> </span><span class="mf">2.34</span><span class="p">,</span><span class="w"> </span><span class="mf">3.45</span><span class="p">,</span><span class="w"> </span><span class="mf">4.56</span><span class="p">,</span><span class="w"> </span><span class="mf">5.67</span><span class="p">,</span><span class="w"> </span><span class="mf">6.78</span><span class="p">,</span><span class="w"> </span><span class="mf">7.89</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>

<p>For some design reasons, the configuration information of algorithms/applications building upon paracel must be read from a config file in stead of command line arguments. We highly recommend <a href="http://json.org/">JSON</a>. Paracel provide a rough json parser which do not support comment and must be parsered in sequence. The simple parser may be not that flexible but can avoid unpredictable mistakes. The <code class="prettyprint">check_parser</code> and <code class="prettyprint">check_parser_v</code> interface below will check if the value is a file or a directory.</p>

<h3 id="struct-json_parser-{&nbsp;public:&nbsp;&nbsp;json_parser(paracel::str_type-fn);">struct json_parser {<br><br>&nbsp;public:<br>&nbsp;&nbsp;json_parser(paracel::str_type fn);</h3>

<h3 id="&nbsp;&nbsp;template-&lt;class-t&gt;&nbsp;&nbsp;t-parse(const-paracel::str_type-&amp;-key);">&nbsp;&nbsp;template &lt;class T&gt;<br>&nbsp;&nbsp;T parse(const paracel::str_type &amp; key);</h3>

<h3 id="&nbsp;&nbsp;template-&lt;class-t&gt;&nbsp;&nbsp;t-check_parse(const-paracel::str_type-&amp;-key);">&nbsp;&nbsp;template &lt;class T&gt;<br>&nbsp;&nbsp;T check_parse(const paracel::str_type &amp; key);</h3>

<h3 id="&nbsp;&nbsp;template-&lt;class-t&gt;&nbsp;&nbsp;std::vector&lt;t&gt;-parse_v(const-paracel::str_type-&amp;-key);">&nbsp;&nbsp;template &lt;class T&gt;<br>&nbsp;&nbsp;std::vector&lt;T&gt; parse_v(const paracel::str_type &amp; key);</h3>

<h3 id="&nbsp;&nbsp;template-&lt;class-t&gt;&nbsp;&nbsp;std::vector&lt;t&gt;-check_parse_v(const-paracel::str_type-&amp;-key);">&nbsp;&nbsp;template &lt;class T&gt;<br>&nbsp;&nbsp;std::vector&lt;T&gt; check_parse_v(const paracel::str_type &amp; key);</h3>

<h3 id="};">};</h3>

<h2 id="random">Random</h2>
<pre><code class="highlight cpp"><span class="cp">#include "utils.hpp"
</span>
<span class="kt">double</span> <span class="nf">pi</span><span class="p">()</span> <span class="p">{</span>

  <span class="kt">int</span> <span class="n">incycle_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">paracel</span><span class="o">::</span><span class="n">random_double</span><span class="p">();</span>
    <span class="kt">double</span> <span class="n">y</span> <span class="o">=</span> <span class="n">paracel</span><span class="o">::</span><span class="n">random_double</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">)</span>  <span class="n">incycle_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">incycle_cnt</span><span class="p">)</span> <span class="o">/</span> <span class="mf">10000000.</span><span class="p">;</span>

<span class="p">}</span>
</code></pre>

<p>Random is the basic assumption of many fields of algorithms. Below we provide two simple interface to randomly generate double value(s) for some initialization usage of machine learning algorithms. More details and interfaces can be found <a href="http://www.cplusplus.com/reference/random/">here</a>.</p>

<h3 id="//-return-a-uniform-random-double-value-in-range(0,-1.)double-random_double();">// return a uniform random double value in range(0, 1.)<br>double random_double();</h3>

<h3 id="//-return-a-list-of-random-double-value-with-upper-bound-upper_bndstd::vector&lt;double&gt;-random_double_list(size_t-len,-double-upper_bnd-=-1.);">// return a list of random double value with upper bound <code class="prettyprint">upper_bnd</code><br>std::vector&lt;double&gt; random_double_list(size_t len, double upper_bnd = 1.);</h3>

<h2 id="string">String</h2>
<pre><code class="highlight cpp"><span class="cp">#include "utils.hpp"
</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">init_lst</span>
        <span class="o">=</span> <span class="p">{</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">,</span> <span class="s">"happy"</span><span class="p">,</span> <span class="s">"new"</span><span class="p">,</span> <span class="s">"year"</span><span class="p">,</span> <span class="s">"2015"</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">seps</span> <span class="o">=</span> <span class="s">"orz"</span><span class="p">;</span>

    <span class="c1">// helloorzworldorzhappyorzneworzyearorz2015
</span>    <span class="k">auto</span> <span class="n">together</span> <span class="o">=</span> <span class="n">paracel</span><span class="o">::</span><span class="n">str_join</span><span class="p">(</span><span class="n">init_lst</span><span class="p">,</span> <span class="n">seps</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">res1</span> <span class="o">=</span> <span class="n">paracel</span><span class="o">::</span><span class="n">str_split_by_word</span><span class="p">(</span><span class="n">together</span><span class="p">,</span> <span class="n">seps</span><span class="p">);</span> <span class="c1">// init_lst
</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">together</span><span class="p">;</span>
    <span class="c1">// init_lst
</span>    <span class="k">auto</span> <span class="n">res2</span> <span class="o">=</span> <span class="n">paracel</span><span class="o">::</span><span class="n">str_split_by_word</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="n">seps</span><span class="p">);</span>

    <span class="n">paracel</span><span class="o">::</span><span class="n">startswith</span><span class="p">(</span><span class="n">together</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">);</span> <span class="c1">// true
</span>    <span class="n">paracel</span><span class="o">::</span><span class="n">startswith</span><span class="p">(</span><span class="n">together</span><span class="p">,</span> <span class="s">"helo"</span><span class="p">);</span> <span class="c1">// false
</span>    <span class="n">paracel</span><span class="o">::</span><span class="n">startswith</span><span class="p">(</span><span class="n">together</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span> <span class="c1">// true
</span>    <span class="n">paracel</span><span class="o">::</span><span class="n">endswith</span><span class="p">(</span><span class="n">together</span><span class="p">,</span> <span class="s">"2015"</span><span class="p">);</span> <span class="c1">// true
</span>    <span class="n">paracel</span><span class="o">::</span><span class="n">endswith</span><span class="p">(</span><span class="n">together</span><span class="p">,</span> <span class="s">"2014"</span><span class="p">);</span> <span class="c1">// false
</span>    <span class="n">paracel</span><span class="o">::</span><span class="n">endswith</span><span class="p">(</span><span class="n">together</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span> <span class="c1">// true
</span>  <span class="p">}</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">tmp</span> <span class="o">=</span> <span class="s">"a|b|c|d|e"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">,</span> <span class="s">"d"</span><span class="p">,</span> <span class="s">"e"</span><span class="p">};</span>
    <span class="k">auto</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">paracel</span><span class="o">::</span><span class="n">str_split</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="sc">'|'</span><span class="p">);</span> <span class="c1">// r
</span>    <span class="k">auto</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">paracel</span><span class="o">::</span><span class="n">str_split</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">"|"</span><span class="p">);</span> <span class="c1">// r
</span>    <span class="k">auto</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">paracel</span><span class="o">::</span><span class="n">str_split</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">"?|?"</span><span class="p">);</span> <span class="c1">// r
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>Paracel provide several extra operations which are included in <code class="prettyprint">std::string</code>.</p>

<h3 id="std::vector&lt;std::string&gt;str_split(const-std::string-&amp;-str,-const-char-sep);">std::vector&lt;std::string&gt;<br>str_split(const std::string &amp; str, const char sep);</h3>

<h3 id="std::vector&lt;std::string&gt;str_split(const-std::string-&amp;-str,-const-std::string-&amp;-seps);">std::vector&lt;std::string&gt;<br>str_split(const std::string &amp; str, const std::string &amp; seps);</h3>

<h3 id="std::vector&lt;std::string&gt;str_split_by_word(const-std::string-&amp;-str,-const-std::string-&amp;-seps);">std::vector&lt;std::string&gt;<br>str_split_by_word(const std::string &amp; str, const std::string &amp; seps);</h3>

<h3 id="std::vector&lt;std::string&gt;str_split_by_word(std::string-&amp;&amp;-str,-const-std::string-&amp;-seps);">std::vector&lt;std::string&gt;<br>str_split_by_word(std::string &amp;&amp; str, const std::string &amp; seps);</h3>

<h3 id="std::string-str_join(const-std::vector&lt;std::string&gt;-&amp;-strlst,-const-std::string-&amp;-seps);">std::string str_join(const std::vector&lt;std::string&gt; &amp; strlst, const std::string &amp; seps);</h3>

<h3 id="bool-startswith(const-std::string-&amp;-str,-const-std::string-&amp;-key);">bool startswith(const std::string &amp; str, const std::string &amp; key);</h3>

<h3 id="bool-endswith(const-std::string-&amp;-str,-const-std::string-&amp;-key);">bool endswith(const std::string &amp; str, const std::string &amp; key);</h3>

<h2 id="misc">Misc</h2>
<pre><code class="highlight cpp"><span class="cp">#include "ps.hpp"
#include "utils.hpp"
#include "paracel_types.hpp"
</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">paralg</span><span class="p">(</span><span class="n">comm</span><span class="p">);</span>
  <span class="n">paracel</span><span class="o">::</span><span class="n">default_id_type</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
  <span class="n">pt</span><span class="o">-&gt;</span><span class="n">paracel_write</span><span class="p">(</span><span class="n">cvt</span><span class="p">(</span><span class="n">id</span><span class="p">),</span> <span class="mf">3.14</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">val</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">paracel_read</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cvt</span><span class="p">(</span><span class="n">id</span><span class="p">));</span>
  <span class="k">delete</span> <span class="n">pt</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">goo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">paracel</span><span class="o">::</span><span class="n">hash_type</span><span class="o">&lt;</span><span class="n">paracel</span><span class="o">::</span><span class="n">default_id_type</span><span class="o">&gt;</span> <span class="n">hfunc</span><span class="p">;</span>
  <span class="n">paracel</span><span class="o">::</span><span class="n">default_id_type</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="n">hfunc</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// 0
</span>  <span class="n">hfunc</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// 1
</span>  <span class="n">hfunc</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="c1">// 2
</span>  <span class="n">hfunc</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="c1">// 3
</span>  <span class="n">paracel</span><span class="o">::</span><span class="n">hash_type</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">hfunc2</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">x</span> <span class="o">=</span> <span class="s">"0"</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="s">"1"</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="s">"2"</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="s">"3"</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="mi">2297668033614959926ULL</span><span class="p">;</span>
  <span class="n">b</span> <span class="o">=</span> <span class="mi">10159970873491820195ULL</span><span class="p">;</span>
  <span class="n">c</span> <span class="o">=</span> <span class="mi">4551451650890805270ULL</span><span class="p">;</span>
  <span class="n">d</span> <span class="o">=</span> <span class="mi">8248777770799913213ULL</span><span class="p">;</span>
  <span class="n">hfunc2</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// a
</span>  <span class="n">hfunc2</span><span class="p">(</span><span class="n">y</span><span class="p">);</span> <span class="c1">// b
</span>  <span class="n">hfunc2</span><span class="p">(</span><span class="n">z</span><span class="p">);</span> <span class="c1">// c
</span>  <span class="n">hfunc2</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="c1">// d
</span><span class="p">}</span>
</code></pre>

<h3 id="template&lt;class-t&gt;-struct-hash-{-&nbsp;&nbsp;size_t-operator()(const-t-&amp;t)-const;-};">template&lt;class T&gt; struct hash { &nbsp;&nbsp;size_t operator()(const T &amp;t) const; };</h3>

<h3 id="double-dot_product(const-std::vector&lt;double&gt;-&amp;-a,-const-std::vector&lt;double&gt;-&amp;-b);">double dot_product(const std::vector&lt;double&gt; &amp; a, const std::vector&lt;double&gt; &amp; b);</h3>

<h3 id="paracel::default_id_type-cvt(std::string-id);">paracel::default_id_type cvt(std::string id);</h3>

<h3 id="std::string-cvt(paracel::default_id_type-id);">std::string cvt(paracel::default_id_type id);</h3>

<h3 id="bool-wait(paracel::async_functor_type-&amp;-future);">bool wait(paracel::async_functor_type &amp; future);</h3>

<aside class="success">
Remember - the key of communication messages must be `std::string`, so you need to convert other type of keys before communication with parameter server.
</aside>

<h1 id="datagen">DataGen</h1>
<pre><code class="highlight shell">python ./tool/datagen.py -m wc -o data.txt

python datagen.py -o sample1.dat -m classification -n 100000 -k 800

python datagen.py -o sample2.dat -m regression -n 100000 -k 100

python ./tool/datagen.py -m pagerank -o pr.dat

python datagen.py -o sample3.dat -m similarity -n 100000 -k 800

python datagen.py -o sample4.dat -m kmeans -n 1000 --ncenters 20 -k 80

<span class="c"># for lda, n refer to the number of documents while k refer to the number of topics</span>
python datagen.py -o sample5.dat -m lda -n 100000 -k 800 -s <span class="s1">'|'</span>

python ./tool/datagen.py -m svd -o svd.dat
</code></pre>

<p>To generate training data for machine learning algorithms and ensure repeatability, we provide a python script named <code class="prettyprint">datagen.py</code> in the <code class="prettyprint">tool</code> folder. Click right <code class="prettyprint">shell</code> tab to see some examples.</p>

<table><thead>
<tr>
<th>Options</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>-h, &ndash;help</td>
<td>show this help message and exit</td>
</tr>
<tr>
<td>-m METHOD, &ndash;method=METHOD</td>
<td>wc, classification, regression, pagerank, similarity, kmeans, lda, svd&hellip;</td>
</tr>
<tr>
<td>-o OUTPUT, &ndash;out=OUTPUT</td>
<td>output file name</td>
</tr>
<tr>
<td>-s SEP, &ndash;sep=SEP</td>
<td>seperator, default: <code class="prettyprint">,</code></td>
</tr>
<tr>
<td>-n SIZE, &ndash;datasize=SIZE</td>
<td>number of training samples</td>
</tr>
<tr>
<td>-k K, &ndash;nfeatures=K</td>
<td>number of features</td>
</tr>
<tr>
<td>&ndash;ncenters=NCENTERS</td>
<td>number of centers for kmeans method</td>
</tr>
</tbody></table>

<h1 id="driver">Driver</h1>
<pre><code class="highlight shell">
PARACEL_INSTALL_PREFIX/prun.py -p 1 -w 16 -m <span class="nb">local</span> -c demo_config.json ./a.out

PARACEL_INSTALL_PREFIX/prun.py -p 10 -w 100 -m mesos --ppn 10 -c word_count_config.json ./local/bin/wc

PARACEL_INSTALL_PREFIX/prun.py -p 10 --m_server mesos --ppn_server 2 --mem_limit_server 1000 -w 100 -m mesos --ppn 10 --mem_limit 500 -c pagerank_config.xml ./local/bin/pagerank
</code></pre>

<p>We provide a python script named <code class="prettyprint">prun.py</code> to run Paracel programs. <code class="prettyprint">prun.py</code> resides at <code class="prettyprint">PARACEL_INSTALL_PREFIX</code> which you were specified during installation. Click <code class="prettyprint">shell</code> tab in the right area to see some examples.</p>

<table><thead>
<tr>
<th>Options</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>-h, &ndash;help</td>
<td>show this help message and exit</td>
</tr>
<tr>
<td>-p PARASRV_NUM, <br>&ndash;snum<br>&nbsp;&nbsp;=PARASRV_NUM</td>
<td>number of parameter servers</td>
</tr>
<tr>
<td>&ndash;m_server <br>&nbsp;&nbsp;=local &#124; mesos &#124; mpi</td>
<td>running method for parameter servers. <br>If not given, set with the same value of -m or <br>&ndash;method</td>
</tr>
<tr>
<td>&ndash;ppn_server <br>&nbsp;&nbsp;=PPN_SERVER</td>
<td>mesos case: procs number per node of parameter servers. <br>If not given, set with the same value of <br>&ndash;ppn</td>
</tr>
<tr>
<td>&ndash;mem_limit_server<br>&nbsp;&nbsp;=MEM_LIMIT_SERVER</td>
<td>mesos case: memory size of each task in parameter servers. <br>If not given, set with the same value of <br>&ndash;mem_limit</td>
</tr>
<tr>
<td>&ndash;hostfile_server <br>&nbsp;&nbsp;=HOSTFILE_SERVER</td>
<td>mpi case: hostfile for mpirun of parameter servers.<br>If not given, set with the same value of <br>&ndash;hostfile</td>
</tr>
<tr>
<td>-w WORKER_NUM, <br>&ndash;wnum<br>&nbsp;&nbsp;=WORKER_NUM</td>
<td>number of workers for learning</td>
</tr>
<tr>
<td>-m local &#124; mesos &#124; mpi,<br>&ndash;method<br>&nbsp;&nbsp;=local &#124; mesos &#124; mpi</td>
<td>running method for workers</td>
</tr>
<tr>
<td>&ndash;ppn=PPN</td>
<td>mesos case: procs number per node for workers</td>
</tr>
<tr>
<td>&ndash;mem_limit<br>&nbsp;&nbsp;=MEM_LIMIT</td>
<td>mesos case: memory size of each task of workers</td>
</tr>
<tr>
<td>&ndash;hostfile=HOSTFILE</td>
<td>mpi case: hostfile for mpirun for workers</td>
</tr>
<tr>
<td>-c CONFIG,<br>&ndash;cfg_file=CONFIG</td>
<td>config file in json fmt, for alg usage</td>
</tr>
</tbody></table>

<aside class="notice">
<br>
1. <b>-c</b> option is a must, all algorithm related parameters have to be written in a config file.
<br>
2. The <b>&ndash;m_server</b> and <b>-m</b> options above refer to what type of cluster you use. Paracel support <a href="http://mesos.apache.org/">mesos</a> clusters, mpi clusters and multiprocessers in a single machine.
<br>
3. Executable files have to be specified at the end.
</aside>

<h1 id="toolkits">Toolkits</h1>

<p>In current version, <a href="https://github.com/douban/paracel/tree/master/alg/">Paracel Toolkits</a> contains the following algorithms:</p>

<ul>
<li><a href="https://github.com/douban/paracel/tree/master/alg/regression/ridge">alg/regression/ridge</a></li>
<li><a href="https://github.com/douban/paracel/tree/master/alg/classification/logistic_regression">alg/classification/logistic_regression</a></li>
<li><a href="https://github.com/douban/paracel/tree/master/alg/clustering/kmeans">alg/clusterting/kmeans</a></li>
<li><a href="https://github.com/douban/paracel/tree/master/alg/graph_alg/pagerank">alg/graph_alg/pagerank</a></li>
<li><a href="https://github.com/douban/paracel/tree/master/alg/recommendation/matrix_factorization">alg/recommendation/matrix_factorization</a></li>
<li><a href="https://github.com/douban/paracel/tree/master/alg/recommendation/similarity_sparse">alg/recommendation/similarity_sparse</a></li>
<li><a href="https://github.com/douban/paracel/tree/master/alg/recommendation/similarity_dense">alg/recommendation/simialrity_dense</a></li>
<li><a href="https://github.com/douban/paracel/tree/master/alg/recommendation/decision_tree_rec">alg/recommendation/decision_tree_rec</a></li>
<li><a href="https://github.com/douban/paracel/tree/master/alg/recommendation/als">alg/recommendation/als</a></li>
<li><a href="https://github.com/douban/paracel/tree/master/alg/topic_model">alg/topic_model/gLDA</a></li>
<li><a href="https://github.com/douban/paracel/tree/master/tool#lasso">tool/lasso_serial</a></li>
<li><a href="https://github.com/douban/paracel/tree/master/tool#logistic_regression_l1">tool/lr_l1_serial</a></li>
<li><a href="https://github.com/douban/paracel/tree/master/tool#svd">tool/svd_serial</a></li>
</ul>

<p>Refer to the link for more description and usage examples.</p>

<h1 id="deployment">Deployment</h1>

<p>Paracel needs some libraries pre-installed in the environment of your cluster.<br>Just follow instructions below step by step.</p>
<aside class="success">
<p>If you are familiar with <a href="https://travis-ci.org/">Travis CI</a>, you could also refer to the <a href="https://github.com/douban/paracel/blob/master/.travis.yml">.travis.yml</a> file for installing Paracel.</p>
</aside>

<h2 id="prerequisites">Prerequisites</h2>

<p>There are a few prerequisites which must be manually satisfied including:</p>

<ul>
<li><a href="https://gcc.gnu.org/">g++</a> (&gt;= 4.7) [Required]

<ul>
<li> Required for compiling Paracel.
<br></li>
<li>clang++ is ok too.</li>
</ul></li>
<li><a href="www.cmake.org">CMake</a> (&gt;= 2.8.9) [Required]

<ul>
<li> Should come with most Mac/Linux systems by default. Recent Ubuntu version will require to install the build-essential package.
<br></li>
</ul></li>
<li>Any version of MPI(<a href="http://www.open-mpi.org/">Open MPI</a> or <a href="http://www.mpich.org/">MPICH2</a>) [Required]

<ul>
<li> Required for running Paracel code distributed.</li>
</ul></li>
</ul>

<aside class="notice">
<p>Under osx, do not install mpich which is a buggy version(stable 3.2) with default brew install, install open-mpi instead: brew install open-mpi.</p>
</aside>

<h2 id="dependencies">Dependencies</h2>

<p>We give different installation guide on different platforms:</p>

<h3 id="gentoo">Gentoo</h3>

<p>We provide the needed ebuild files for you in the <code class="prettyprint">ebuild</code> directory and you can install all this libraries in any order.</p>

<h3 id="ubuntu(12.04-lts)-/-debian(wheezy)">Ubuntu(12.04 LTS) / Debian(Wheezy)</h3>

<ol>
<li><code class="prettyprint">sudo apt-get install libboost-dev</code>
<br><br></li>
<li><code class="prettyprint">sudo apt-get install libzmq-dev</code>
<br><em>Make sure the version is greater than 3.2.4 by typing <code class="prettyprint">apt-cache show libzmq-dev</code>, if no related version found, you must manually download and install it at <a href="http://zeromq.org/intro:get-the-software">here</a>.</em>
<br><br></li>
<li><code class="prettyprint">sudo apt-get install libeigen3-dev</code>
<br><br></li>
<li><code class="prettyprint">sudo apt-get install libgoogle-glog-dev</code>
<br><br></li>
<li><em>Install a increment version of <a href="https://github.com/xunzhang/msgpack-c">Msgpack-C</a> which supports some C++11 types. Here you must manually clone and install the library:</em>
<br><code class="prettyprint">git clone https://github.com/xunzhang/msgpack-c.git</code>
<br><code class="prettyprint">cd msgpack-c;</code>
<br><code class="prettyprint">./bootstrap; ./configure; make; sudo make install</code>
<br><br></li>
<li><code class="prettyprint">sudo apt-get install libgflags-dev</code><br> <em>Make sure version of gflags is greater than 2.0, if no corresponding version could be found, you should install it manually.</em></li>
</ol>

<h3 id="opensuse(13.2)">OpenSUSE(13.2)</h3>

<ol>
<li><code class="prettyprint">sudo zypper in boost-devel</code>
<br><br></li>
<li><code class="prettyprint">sudo zypper in zeromq-devel</code>
<br><em>Make sure the version is greater than 3.2.4 by typing <code class="prettyprint">zypper info zeromq_devel</code>, if no related version found, you must manually download and install it at <a href="http://zeromq.org/intro:get-the-software">here</a>.</em>
<br><br></li>
<li><code class="prettyprint">sudo zypper in eigen3-devel</code>
<br><br></li>
<li><em>Install a increment version of <a href="https://github.com/xunzhang/msgpack-c">Msgpack-C</a> which supports some C++11 types. Here you must manually clone and install the library:</em>
<br><code class="prettyprint">git clone https://github.com/xunzhang/msgpack-c.git</code>
<br><code class="prettyprint">cd msgpack-c;</code>
<br><code class="prettyprint">./bootstrap; ./configure; make; sudo make install</code>
<br><br></li>
<li><code class="prettyprint">sudo apt-get install libgflags-dev</code><br> <em>Make sure version of gflags is greater than 2.0, if no corresponding version could be found, you should install it manually.</em></li>
</ol>

<h3 id="centos(7)">Centos(7)</h3>

<ol>
<li><code class="prettyprint">sudo yum install boost-devel</code>
<br><br></li>
<li><code class="prettyprint">sudo yum install zeromq-devel</code>
<br><em>Make sure the version is greater than 3.2.4 by typing <code class="prettyprint">yum info zeromq-devel</code>, if no related version found, you must manually download and install it at <a href="http://zeromq.org/intro:get-the-software">here</a>.</em>
<br><br></li>
<li><code class="prettyprint">sudo yum install  eigen3-devel</code>
<br><br></li>
<li><em>Install a increment version of <a href="https://github.com/xunzhang/msgpack-c">Msgpack-C</a> which supports some C++11 types. Here you must manually clone and install the library:</em>
<br><code class="prettyprint">git clone https://github.com/xunzhang/msgpack-c.git</code>
<br><code class="prettyprint">cd msgpack-c;</code>
<br><code class="prettyprint">./bootstrap; ./configure; make; sudo make install</code>
<br><br></li>
<li><code class="prettyprint">sudo apt-get install libgflags-dev</code><br> <em>Make sure version of gflags is greater than 2.0, if no corresponding version could be found, you should install it manually.</em></li>
</ol>

<h3 id="archlinux">ArchLinux</h3>

<ol>
<li><code class="prettyprint">sudo pacman -S boost</code>
<br><br></li>
<li><code class="prettyprint">sudo pacman -S zeromq</code>
<br><em>Make sure the version is greater than 3.2.4.</em>
<br><br></li>
<li><code class="prettyprint">sudo pacman -S eigen3</code>
<br><br></li>
<li><em>Install a increment version of <a href="https://github.com/xunzhang/msgpack-c">Msgpack-C</a> which supports some C++11 types. Here you must manually clone and install the library:</em>
<br><code class="prettyprint">git clone https://github.com/xunzhang/msgpack-c.git</code>
<br><code class="prettyprint">cd msgpack-c;</code>
<br><code class="prettyprint">./bootstrap; ./configure; make; sudo make install</code>
<br><br></li>
<li><code class="prettyprint">sudo apt-get install libgflags-dev</code><br> <em>Make sure version of gflags is greater than 2.0, if no corresponding version could be found, you should install it manually.</em></li>
</ol>

<h3 id="mac-os-x">Mac OS X</h3>
<ol>
<li><code class="prettyprint">brew install open-mpi</code>
<br><br></li>
<li><code class="prettyprint">brew install boost</code>
<br><br></li>
<li><code class="prettyprint">brew install zmq</code>
<br><br></li>
<li><code class="prettyprint">brew install gflags</code>
<br><br></li>
<li><code class="prettyprint">brew install glog</code>
<br><br></li>
<li><em>Install msgpack-C</em>
<br><code class="prettyprint">wget -O "/tmp/msgpack-c-1.4.2.tar.gz" "https://github.com/msgpack/msgpack-c/archive/cpp-1.4.2.tar.gz"</code>
<br><code class="prettyprint">tar -zxvf "/tmp/msgpack-c-1.4.2.tar.gz" "msgpack-c-cpp-1.4.2"</code>
<br><code class="prettyprint">cd "/tmp/msgpack-c-cpp-1.4.2"</code>
<br><code class="prettyprint">./bootstrap; ./configure; make; sudo make install</code>
<br><br></li>
<li><em>Install Eigen3</em>
<br><code class="prettyprint">wget -O "3.1.0.tar.gz" "http://bitbucket.org/eigen/eigen/get/3.1.0.tar.gz"</code>
<br><code class="prettyprint">tar -zxvf "3.1.0.tar.gz" "eigen-eigen-ca142d0540d3"</code>
<br><code class="prettyprint">mkdir -p eigen-eigen-ca142d0540d3/build</code>
<br><code class="prettyprint">cd eigen-eigen-ca142d0540d3/build</code>
<br><code class="prettyprint">cmake ..; make; make install;</code>
<br><br></li>
</ol>

<h2 id="downloading-paracel">Downloading Paracel</h2>

<p>You can download Paracel directly from the github repository. The git command line for cloning the reposotory is:</p>

<p><code class="prettyprint">git clone https://github.com/douban/paracel.git</code>
    <br><br>
    <code class="prettyprint">cd paracel</code></p>

<h2 id="compiling-paracel">Compiling Paracel</h2>

<p><code class="prettyprint">mkdir build; cd build</code></p>

<p><code class="prettyprint">cmake -DCMAKE_BUILD_TYPE=Release ..</code>
<br><em>You can also specify <code class="prettyprint">-DCMAKE_INSTALL_PREFIX</code> with the path where you want Paracel to be installed. For example, type <br><code class="prettyprint">cmake -DCMAKE_INSTALL_PREFIX=your_paracel_install_path ..</code> instead.</em></p>

<p><code class="prettyprint">make -j 4</code>
<br><em>The above command will perform up to 4 build tasks in parallel, you can specify the number of tasks you want according to your machine.</em></p>
<p><code class="prettyprint">make test</code></p>
<p><code class="prettyprint">make install</code></p>

<aside class="notice">
<p>Now you have successfully installed Paracel in a single node. After distributing the built out binary packge into clusters, you could run Paracel programs in a cluster(so far a MPI cluster). Moreover, if you want to run Paracel programs in a mesos cluster, you should firstly deploy the mesos framework, then distribute the built out paracel packages into this cluster. We will not mention <a href="http://mesos.apache.org/gettingstarted/">the mesos installation process</a> inside this document.</p>
<p>Current version of Paracel(0.3.x) only supports Mesos cluster and MPI cluster(of course you could running Paracel programs in a single node with multiply processers). We strongly recommend the mesos mode which is running and testing everyday internal at Douban Company. Besides, since Yarn framework is becoming more and more popular in apache community, we plan to support that in the future version of Paracel.</p>
<p>If you meet any kinds of problems during the deployment of Paracel, mesos and related libraries, just feel free to contact us via email. Another good way is to open an issue in Github or start a thread in Paracel's google group.</p>
</aside>

<h2 id ="running-paracel">Running Paracel</h2>
<br><p><em>Firstly, you must set up linking option before running paracel programs. There are two typical ways to do that:</em></p>
<p><em>1. Add your linking path(PARACEL_INSTALL_PREFIX/lib) into /etc/ld.so.conf.(recommended)</em></p>
<p><em>2. Set <code class="prettyprint">LD_LIBRARY_PATH</code>(linux) or <code class="prettyprint">DYLD_LIBRARY_PATH</code>(osx) variable with <code class="prettyprint">PARACEL_INSTALL_PREFIX/lib</code>. For example, suppose we have installed Paracel into <code class="prettyprint">/usr/local</code>folder. Then we should <code class="prettyprint">export LD_LIBRARY_PATH=/usr/local/lib</code>.</em></p>
<p>After that, we could run Paracel programs. Here we will take a word cound example under MacOS system:</p>
<p><code class="prettyprint">1. cd /tmp</code></p>
<p><code class="prettyprint">2. python /usr/local/bin/tool/datagen.py -m wc -o data.txt</code></p>
<p>3. Get a sample configuration file for our word count example: <br><code class="prettyprint">wget "paracel.io/data/travis_demo_osx.json"</code></p>
<p>4. Run word count example in a single node with multiply processers: <code class="prettyprint">/usr/local/prun.py -p 4 -w 4 -c travis_demo_osx.json -m local /usr/local/bin/wc</code></p>
<p>There are lots of programs in current version of Paracel, check out <a href="http://paracel.io/docs/api_reference.html#toolkits">this link</a> for more examples(each link contains a README.md for you to begin with).</p>
<p>If you want to contribute to Paracel project or try to write distributed machine learning or graph algorithms upon Paracel, <a href="http://paracel.io/docs/quick_tutorial.html">here</a> is a good start for you.</p>
<aside class="notice">
<p>If you meet any kinds of problems running of Paracel programs, just feel free to contact us via email. Another good way is to open an issue in Github or start a thread in Paracel's google group.</p>
</aside>

<h2 id ="build-outside">Build Algorithm Outside paracel Folder</h2>
<p>A recommended way to build Paracel algorithms is writing a <code class="prettyprint">CMakeLists.txt</code> file inside paracel folder.<p>
<p>But in many cases, particular among the scenarios of industry users, they need to build algorithms that developed upon Paracel framework externally.</p>
<p>The dependency is not that complicated and we give <a href="https://github.com/douban/paracel/tree/master/external_usage">a real example</a> for doing that.</p>
<aside class="notice">
<p>If you meet any kinds of related problems, just feel free to contact us via email. Another good way is to open an issue in Github or start a thread in Paracel's google group.</p>
</aside>

<h1 id="paracel-faq">Paracel FAQ</h1>

<p><br>
<strong>How does Paracel relate to MPI?</strong>
<br>
Paracel use MPI to create worker processers, then parallelly load input data(it will do some communication in this step). Communication between workers and servers is nothing to do with MPI. And we provide a C++ wrapper for MPI communication, you can directly do message passing between workers in some cases. See more details in the <a href="#communicator">Communicator</a> section.
<br><br></p>

<p><strong>What is parameter server?</strong>
<br>
Parameter server is a global and distributed key-value store brings to a novel way for communication. In this paradigm, if worker <code class="prettyprint">W1</code> needs to talk to worker <code class="prettyprint">W2</code>, <code class="prettyprint">W1</code> has to push his words to server <code class="prettyprint">S</code> for <code class="prettyprint">W2</code> to pull. It is kind of indirect, but you can get more flexibility and simplicity from that.
<br><br></p>

<p><strong>What is the difference between Paracel and Spark/GraphLab framework?</strong>
<br>
The question is hard to answer in brief, Spark and GraphLab are both outstanding distributed computational framework with many advantages, but there are also some limitations of them:
<br>Spark project follows the mapreduce paradigm which is not that straightforward and flexible for algorithms in some specialized domains such as machine learning, graph and so on. If you think the transformation of RDD as a set of basis functions, they are not fit for all the applications. For example, Spark implements Bagel for graph processing which follows Google&rsquo;s Pregel graph processing model(not mapreduce at all). Spark is more suitable and easily used for data statistics problems and problems with narrow dependency.
<br>Graphlab framework is designed for graph algorithms which focus more on efficiency. In the other end, your application code is so tricky that it will look very different from its original logic. Also you have to transform your machine learning problems to GraphLab&rsquo;s model and it may be too low-level for application developers.
<br>Paracel is a framework in between, it is more high-level and easily to use than GraphLab and more low-level/flexible than Spark, users can write communication code in Paracel. Developers may focus more on their application logic to build distributed algorithms. Paracel is original designed for machine learning problems.
<br><br></p>

<p><strong>What programming languages does Paracel support?</strong>
<br>
C++ only, for the consideration of computational efficiency.
<br><br></p>

<p><strong>What is the largest data size Paracel can scale to?</strong>
<br>
It depends on the number of processers you have. At Douban, the usual data size is about 100GB.
<br><br></p>

<p><strong>Is Paracel only fit for machine learning problems?</strong>
<br>
Not exactly, Paracel is designed for many machine problems as well as graph algorithms and scientific problems. For example, pagerank algorithm in Paracel is really straightfoward compare to a two-phase mapreduce implementation.
<br><br></p>

<p><strong>How can I write a distributed algorithm upon Paracel framework?</strong>
<br>
Follow <a href="http://paracel.io/docs/quick_tutorial.html#WriteaParacelApplication">the third section</a> in quick tutorial page step by step.
<br><br></p>

<p><strong>How large a cluster can Paracel scale to?</strong>
<br>
In the current version, we have tested the cluster scale to 100+ nodes with 5000+ processers.
<br><br></p>

<p><strong>How can I run Paracel on a cluster?</strong>
<br>
Firstly, set up a cluster environment with either mpi or mesos. Secondly, make sure Paracel is successfully installed on your clusters. More details can be found <a href="#deployment">here</a>. Then use <code class="prettyprint">-m</code> option with <code class="prettyprint">mpi</code> or <code class="prettyprint">mesos</code> in your <code class="prettyprint">prun.py</code> script.
<br><br></p>

<p><strong>Can I run Paracel programs with docker?</strong>
<br>
<br><br></p>

<p><strong>How can I contribute to Paracel?</strong>
<br>
Just fork the <a href="https://github.com/douban/paracel/fork">repository</a> and send a pull request on <a href="https://github.com/douban/paracel">github</a>.
<br><br></p>

<p><strong>What new features will Paracel import in the future?</strong>
<br>More data source formats such as gzip and bz2.
<br>Streaming Paracel: fault tolerance to ensure service-like application reliable.
<br>Data flow interfaces with which you can process data like a pipeline.
<br>ParacelSQL.
<br><br></p>

<blockquote>
<p>1.Deadlock mistake</p>
</blockquote>
<pre><code class="highlight cpp"><span class="kt">void</span> <span class="nf">deadlock_mistake</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">get_worker_id</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">paracel_sync</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<blockquote>
<p>2.Wrong type mistake</p>
</blockquote>
<pre><code class="highlight cpp"><span class="kt">void</span> <span class="nf">wrong_type_mistake</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">paracel_write</span><span class="p">(</span><span class="s">"key1"</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">);</span>
  <span class="n">paracel_write</span><span class="p">(</span><span class="s">"key2"</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">keys</span> <span class="o">=</span> <span class="p">{</span><span class="s">"key1"</span><span class="p">,</span> <span class="s">"key2"</span><span class="p">};</span>
  <span class="c1">// use double in stead of vector&lt;double&gt;
</span>  <span class="k">auto</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">paracel_read_multi</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">keys</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>

<p><strong>This document is terrible and I have a lot of questions, where can I get more help?</strong>
<br>
You can initiate a discussion at this <a href="https://groups.google.com/forum/#!forum/paracel">group</a> or write an email to <a href="mailto:xunzhangthu@gmail.com">xunzhangthu@gmail.com</a>, <a href="mailto:algorithm@douban.com">algorithm@douban.com</a>.
Another good and quick way is to open an issue in Github.
<br><br></p>

<p><strong>Can I write a Paracel application outside the Paracel directory?</strong>
<br>
Yes, of course. In this case you must modify cmake files and be responsible to the linking relations of your code. If you are not professional, we strongly do not suggest you to do that.
<br><br></p>

<p><strong>Common mistakes.</strong>
<br>
1. Deadlock mistake: in the example on the right, only worker 0 can access the <code class="prettyprint">if</code> clause while <code class="prettyprint">paracel_sync</code> requires all workers to execute this line.<br>
2. Wrong type specified mistake: see the interface at <a href="#communication">Paralg</a> section, the return type is <code class="prettyprint">std::vector&lt;V&gt;</code>, so in the right example, you have to only use <code class="prettyprint">double</code>.
<br><br></p>


      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="cpp">cpp</a>
                <a href="#" data-language-name="python">python</a>
                <a href="#" data-language-name="shell">shell</a>
                <a href="#" data-language-name="json">json</a>
          </div>
      </div>
    </div>
  </body>
</html>
